<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Util.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Util" rel="Chapter" href="Util.html">
<link title="Lattice" rel="Chapter" href="Lattice.html"><title>Lattice</title>
</head>
<body>
<div class="navbar"><a href="Util.html">Previous</a>
&nbsp;<a href="index.html">Up</a>
&nbsp;</div>
<center><h1>Module <a href="type_Lattice.html">Lattice</a></h1></center>
<br>
<pre><span class="keyword">module</span> Lattice: <code class="code">sig</code> <a href="Lattice.html">..</a> <code class="code">end</code></pre>The lattice module.  NB:  weights on edges should represent probabilities, but
     they needn't sum to one.  i.e. the structure of the lattice may have implicit 
     conditioning on some outside event.<br>
<hr width="100%">
<pre><span class="keyword">type</span> <a name="TYPEnode"></a><code class="type"></code>node = <code class="type">int * int</code> </pre>
<div class="info">
<code class="code">(i,j)</code> represents the <code class="code">j</code>th state at time <code class="code">i</code><br>
</div>

<br><code><span class="keyword">type</span> <a name="TYPElattice"></a><code class="type">'a</code> lattice = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nodes&nbsp;: <code class="type">'a array array</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nodes.(i).(j)</code> represents state <code class="code">j</code> at time <code class="code">i</code></td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>edges_from&nbsp;: <code class="type">(<a href="Lattice.html#TYPEnode">node</a>, (<a href="Lattice.html#TYPEnode">node</a> * float) array) Util.Ht.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>edges_to&nbsp;: <code class="type">(<a href="Lattice.html#TYPEnode">node</a>, (<a href="Lattice.html#TYPEnode">node</a> * float) array) Util.Ht.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>edges&nbsp;: <code class="type">(<a href="Lattice.html#TYPEnode">node</a> * <a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >edges and their weights</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>alphas&nbsp;: <code class="type">(<a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t option</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>betas&nbsp;: <code class="type">(<a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t option</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span>z&nbsp;: <code class="type">float option</code>;</code></td>

</tr></table>
}


<pre><span class="keyword">val</span> <a name="VALmk_lattice"></a><a href="code_VALLattice.mk_lattice.html">mk_lattice</a> : <code class="type">'a array array -><br>       (<a href="Lattice.html#TYPEnode">node</a> * <a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t -> 'a <a href="Lattice.html#TYPElattice">lattice</a></code></pre><div class="info">
<code class="code">mk_lattice nodes edges</code> makes a lattice datatype.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_viterbi_path"></a><a href="code_VALLattice.get_viterbi_path.html">get_viterbi_path</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> 'b -> <a href="Lattice.html#TYPEnode">node</a> list</code></pre><div class="info">
<code class="code">get_viterbi_path l</code> returns the highest probability path through lattice <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_viterbi_symbols"></a><a href="code_VALLattice.get_viterbi_symbols.html">get_viterbi_symbols</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> 'b -> 'a list</code></pre><div class="info">
<code class="code">get_viterbi_symbols l</code> returns the symbols along the highest probability path
    through lattice <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_alphas"></a><a href="code_VALLattice.get_alphas.html">get_alphas</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> (<a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t</code></pre><div class="info">
alpha.(i).(j) is alpha_j (i) in Mike Collins' notation
    i.e. alpha.(i).(j) is the sum of weights of all paths from the source to Node (i,j) 
    <code class="code">i.e. state j at time i</code><br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_betas"></a><a href="code_VALLattice.get_betas.html">get_betas</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> (<a href="Lattice.html#TYPEnode">node</a>, float) Util.Ht.t</code></pre><div class="info">
beta.(i).(j) is beta_j (i) in Mike Collins' notation 
    i.e. beta.(i).(j) is the sum of weights of all paths from Node (i,j) to the target<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_z"></a><a href="code_VALLattice.get_z.html">get_z</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> float</code></pre><div class="info">
Get the sum of weights of all paths through the lattice (partition function).
    If the lattice represents a markov model conditioned on some fact, then this
    will give us the probability of that fact.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_node_prob"></a><a href="code_VALLattice.get_node_prob.html">get_node_prob</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> <a href="Lattice.html#TYPEnode">node</a> -> float</code></pre><div class="info">
<code class="code">get_node_prob l n</code> returns the probability of passing through node <code class="code">n</code> in 
    lattice <code class="code">l</code>.<br>
</div>
<pre><span class="keyword">val</span> <a name="VALget_edge_prob"></a><a href="code_VALLattice.get_edge_prob.html">get_edge_prob</a> : <code class="type">'a <a href="Lattice.html#TYPElattice">lattice</a> -> <a href="Lattice.html#TYPEnode">node</a> -> <a href="Lattice.html#TYPEnode">node</a> -> float</code></pre><div class="info">
<code class="code">get_edge_prob l src trg</code> returns the probability of traversing the edge from 
    node <code class="code">src</code> to node <code class="code">trg</code> in lattice <code class="code">l</code>.<br>
</div>
</body></html>