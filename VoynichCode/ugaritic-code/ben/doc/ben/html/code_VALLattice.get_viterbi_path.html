<html><head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Util" rel="Chapter" href="Util.html">
<link title="Lattice" rel="Chapter" href="Lattice.html"><title>Lattice.get_viterbi_path</title>
</head>
<body>
<code class="code"><span class="keyword">let</span>&nbsp;get_viterbi_path&nbsp;(l&nbsp;:&nbsp;<span class="keywordsign">'</span>a&nbsp;lattice)&nbsp;to_string&nbsp;:&nbsp;node&nbsp;list&nbsp;=&nbsp;<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;output_graph&nbsp;to_string&nbsp;l&nbsp;"graph.dot";&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;nodes,&nbsp;edges_to&nbsp;=&nbsp;l.nodes,&nbsp;l.edges_to&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;len&nbsp;=&nbsp;<span class="constructor">A</span>.length&nbsp;nodes&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;pi,&nbsp;bp&nbsp;=&nbsp;<span class="constructor">Ht</span>.create&nbsp;1000,&nbsp;<span class="constructor">Ht</span>.create&nbsp;1000&nbsp;<span class="keyword">in</span>&nbsp;&nbsp;<span class="comment">(*dynamic&nbsp;program&nbsp;back-pointer&nbsp;tables&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="constructor">Ht</span>.replace&nbsp;pi&nbsp;(0,0)&nbsp;1.;<br>
&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;i&nbsp;=&nbsp;1&nbsp;<span class="keyword">to</span>&nbsp;(len&nbsp;-&nbsp;1)&nbsp;<span class="keyword">do</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;j&nbsp;=&nbsp;0&nbsp;<span class="keyword">to</span>&nbsp;<span class="constructor">A</span>.length&nbsp;nodes.(i)&nbsp;-&nbsp;1&nbsp;<span class="keyword">do</span>&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;trg&nbsp;=&nbsp;(i,j)&nbsp;<span class="keyword">in</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print_endline&nbsp;&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Sexp.to_string_hum&nbsp;&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sexp_of_hashtbl&nbsp;&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sexp_of_node&nbsp;(sexp_of_array&nbsp;(sexp_of_pair&nbsp;sexp_of_node&nbsp;sexp_of_float))&nbsp;edges_to));&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;"Length:&nbsp;edges_to&nbsp;=&nbsp;%d\n"&nbsp;(Ht.length&nbsp;edges_to);&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;"(%d,&nbsp;%d)\n"&nbsp;i&nbsp;j;&nbsp;*)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;not&nbsp;(<span class="constructor">Ht</span>.mem&nbsp;edges_to&nbsp;trg)&nbsp;<span class="keyword">then</span>&nbsp;()&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;in_edges&nbsp;=&nbsp;<span class="constructor">Ht</span>.find&nbsp;edges_to&nbsp;trg&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;in_scores&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">A</span>.map&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="keyword">fun</span>&nbsp;(src,&nbsp;w)&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;w&nbsp;*.&nbsp;(<span class="constructor">Ht</span>.get&nbsp;pi&nbsp;src&nbsp;0.))&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in_edges&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;mx_i,&nbsp;mx_scr&nbsp;=&nbsp;max_itemi&nbsp;in_scores&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;bst_src&nbsp;=&nbsp;fst&nbsp;in_edges.(mx_i)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Ht</span>.replace&nbsp;pi&nbsp;trg&nbsp;mx_scr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">Ht</span>.replace&nbsp;bp&nbsp;trg&nbsp;bst_src<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">done</span><br>
&nbsp;&nbsp;<span class="keyword">done</span>;<br>
&nbsp;&nbsp;<span class="comment">(*&nbsp;trace&nbsp;through&nbsp;the&nbsp;back-pointers...&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;let&nbsp;s&nbsp;=&nbsp;Sexp.to_string_hum&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sexp_of_hashtbl&nbsp;sexp_of_node&nbsp;sexp_of_node&nbsp;bp)&nbsp;in&nbsp;*)</span><br>
<span class="comment">(*&nbsp;&nbsp;&nbsp;print_endline&nbsp;s;&nbsp;*)</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;<span class="keyword">rec</span>&nbsp;f&nbsp;(t,n)&nbsp;l&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;t&nbsp;=&nbsp;0&nbsp;<span class="keyword">then</span>&nbsp;l<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;hd&nbsp;=&nbsp;<span class="constructor">Ht</span>.find&nbsp;bp&nbsp;(t,n)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;hd&nbsp;(hd&nbsp;::&nbsp;l)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;<span class="keyword">let</span>&nbsp;final&nbsp;=&nbsp;(len&nbsp;-&nbsp;1,&nbsp;0)&nbsp;<span class="keyword">in</span><br>
&nbsp;&nbsp;f&nbsp;final&nbsp;[final]</code></body></html>