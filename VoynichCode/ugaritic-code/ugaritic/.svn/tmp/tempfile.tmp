TYPE_CONV_PATH "Something"

open Util, Batteries, Batteries.Standard, Print
module Fst = OpenFst

let _DEBUG = ref false;;

let start_time = iof (Unix.time ());;
let printf fmt = ksprintf print_endline fmt;;
let drintf fmt = if !_DEBUG then ksprintf print_endline fmt else ifprintf true fmt;;

let rng = Gsl_rng.make (Gsl_rng.default ());;
Random.self_init ();;
let seed = Random.nativeint (Nativeint.of_int max_int);;
Gsl_rng.set rng seed;;
let set_seed n =
  Gsl_rng.set rng (Nativeint.of_int n);
  Random.init n
;;
set_seed 0;;
let mtrng = Fst.new_rng (Nativeint.to_int seed);;
let datadir = "/afs/csail.mit.edu/u/b/bsnyder/scratch/ugaritic/";;

let gamma_sub_true   = 5.0;;
let gamma_sub_false  = 0.01;;
let gamma_ins_true   = 100.0;;
let gamma_ins_false  = 0.01;;
let gamma_del_true   = 5.0;;
let gamma_del_false  = 0.0000001;;

let alpha_pre        = 0.001;;
let alpha_stm        = 1.0;;
let alpha_suf        = 0.001;;

let del_lp     = [|-1.0; -50.0; -100.0|];;
let ins_lp     = [|neg_infinity; -50.0; -1.0; -50.0|];;
let subug_lp   = [|-100.0; -1.0; -1.0; -10.0|];;
let subhb_lp   = [|-100.0; -1.0; -1.0; -10.0|];;
let default_pos = "n"

let rounds = 200;;

<<<<<<< .mine
let anneal        = false;;
let temp_anneal   = ref false;;
let anneal_begin  = 10.0;;
let anneal_end    = 100.0;; 
let anneal_burn   = 0;;
=======
let anneal        = false;;
let anneal_begin  = 1.0;;
let anneal_end    = 5.0;; 
let anneal_burn   = 15;;
>>>>>>> .r1019
let schedule =
   let n = rounds - anneal_burn in
      let d = (anneal_end -. anneal_begin) /. (foi n) in 
      A.init rounds (fun i -> if i < anneal_burn then 1. else d *. (foi (i - anneal_burn)) +. anneal_begin)
;;

type fst = Fst.fst with sexp
type edit = Ins of int | Del of int | Sub of (int * int) | End with sexp
type morph = int array with sexp
type pos = string with sexp
type morph_type = Pre | Stm | Suf with sexp
let printer_morphtype k x = k (fun oc -> IO.nwrite oc (SExpr.to_string_hum (sexp_of_morph_type x)));;
type word = {
   mutable pre   : morph;
   mutable stm   : morph;
   mutable suf   : morph;   } with sexp
;;
type entry = {
   true_word_ug         : word;
   true_words_hb        : word list;
   true_pos             : pos;
   true_cog             : bool;
   segments_ug          : word array;
   mutable word_hb      : word;
   mutable word_ug      : word;
   mutable pos          : pos;
   mutable cog          : bool;
   mutable cog_prob     : float;
   mutable xxx          : bool;
   mutable best_hb      : word;
   mutable best_ug      : word;
   mutable best_pos     : pos;
   mutable best_cog     : bool;
   mutable best_prob    : float;
   mutable pre_ed       : edit list;
   mutable stm_ed       : edit list;
   mutable suf_ed       : edit list;   } with sexp
;;
type mapping = int list array with sexp
type fsa_record = {pre_fsa : fst; stm_fsa : fst; suf_fsa : fst} with sexp
type data = {
   encode_ug_chr        : char -> int;
   decode_ug_chr        : int -> char;
   encode_hb_chr        : char -> int;
   decode_hb_chr        : int -> char;
   encode_hb            : string -> morph;
   decode_hb            : morph -> string;
   encode_ug            : string -> morph;
   decode_ug            : morph -> string;
   num_hb_chr           : int;
   num_ug_chr           : int;
   poses                : pos array;
   fsas                 : (pos, fsa_record) Ht.t;
   mutable n            : float;
   entries              : entry array;
   mapping              : mapping;  (* ug -> hb *)
   mapping2             : mapping;  (* hb -> ug *)
   edits                : edit list;
   edit_count           : (edit, float) Ht.t;
   mutable edit_sum     : float;
   pos_count            : (pos, float) Ht.t;
   stm_count            : ((morph * pos), (edit list, float) Ht.t) Ht.t;
   pre_count            : ((morph * pos), (edit list, float) Ht.t) Ht.t;
   suf_count            : ((morph * pos), (edit list, float) Ht.t) Ht.t;
   stm_sum              : ((morph * pos), float) Ht.t;
   pre_sum              : ((morph * pos), float) Ht.t;
   suf_sum              : ((morph * pos), float) Ht.t;
   gammas               : (edit, bool) Ht.t;  (* indicator variables for slab (true) vs spike (false) *) 
   mutable alphas_sum   : float;  (* should rename... these are the alphas (dirichlet hyperparameters) for the base distribution(s) *)
} with sexp 
;;
type seg_entry = {prob : float; fsa_rec : fsa_record; seg : word; npos : string} with sexp

let fsa_cache = Ht.create 2000;;

let read_ugaritic_data ug_data init_seg_file hb_letters ug_letters pos_list mapping_file mapping_file2 =
   let int_of_hb = Ht.of_file char_of_string int_of_string (datadir ^ hb_letters) in
   let hb_of_int = Ht.reverse int_of_hb in
   let int_of_ug = Ht.of_file char_of_string int_of_string (datadir ^ ug_letters) in
   let ug_of_int = Ht.reverse int_of_ug in
   let encode_hb_chr = Ht.find int_of_hb in
   let decode_hb_chr = Ht.find hb_of_int in
   let encode_ug_chr = Ht.find int_of_ug in
   let decode_ug_chr = Ht.find ug_of_int in
   let encode_hb = A.map encode_hb_chr >> aol >> S.explode in
   let decode_hb = S.implode >> loa >> A.map decode_hb_chr in
   let encode_ug = A.map encode_ug_chr >> aol >> S.explode in
   let decode_ug = S.implode >> loa >> A.map decode_ug_chr in
   (* let init_segs = A.slice ~last:50 (array_of_file (datadir ^ init_seg_file)) in *)
   let init_segs = array_of_file (datadir ^ init_seg_file) in
   let get_mapping fn =
      let res = A.make (Ht.length int_of_ug) [] in 
      let proc_ln ln = 
         if ln.[0] != '#' then
            let ug, heb = S.split ln "\t" in
            let i = (encode_ug_chr >> char_of_string) ug in
            let v = L.map (encode_hb_chr >> char_of_string) (S.nsplit (S.strip heb) " ") in 
            res.(i) <- v
      in
      A.iter proc_ln (array_of_file fn);
      res
   in
   let get_mapping2 fn =
      let res = A.make (Ht.length int_of_hb) [] in 
      let proc_ln ln = 
         if ln.[0] != '#' then
            let hb, ug = S.split ln "\t" in
            let i = (encode_hb_chr >> char_of_string) hb in
            let v = L.map (encode_ug_chr >> char_of_string) (S.nsplit (S.strip ug) " ") in 
            res.(i) <- v
      in
      A.iter proc_ln (array_of_file fn);
      res
   in
   let get_segmentations (w : int array) =
      (* assumptions: stem >= 2, pre <= 2, suf <= 2 *)   
      let num_segs = match A.length w with
         | x when x >= 6 -> 9
         | 5 -> 8
         | 4 -> 6
         | 3 -> 3
         | _ -> 1 in
      let segs = A.make num_segs {pre = [||]; stm = [||]; suf = [||]} in
      let pre = ref [||] in
      let rest = ref w in
      let do_pre = ref true in
      let i = ref 0 in
      while (!do_pre) do
         let stm = ref !rest in
         let suf = ref [||] in
         let do_suf = ref true in
         while (!do_suf) do   
            segs.(!i) <- {pre = !pre; stm = !stm; suf = !suf};
            incr i;
            if A.length !stm > 2 && A.length !suf < 2 then begin
               suf := A.init (A.length !suf + 1) (fun j -> if j = 0 then A.last !stm else !suf.(j-1));
               stm := A.slice ~last:(-1) !stm;
            end else 
               do_suf := false
         done;
         if A.length !rest > 2 && A.length !pre < 2 then begin
            pre := A.init (A.length !pre + 1) (fun j -> if j = A.length !pre then !rest.(0) else !pre.(j));
            rest := A.slice ~first:1 !rest;
         end else 
            do_pre := false
      done;
      assert (!i = num_segs);
      segs
   in
   let proc_ln i ln =
      let proc_word (encode : string -> int array) w : word =
         let morphs = S.nsplita w "-" in
         match A.length morphs with
            | 3 ->
               if not (morphs.(0).[0] = '#' && morphs.(2).[S.length morphs.(2) - 1] = '#') then begin
                  A.print id morphs;
                  failwith "prefix and suffix should be marked"
               end;
               let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
               {pre = encode res.(0); stm = encode res.(1); suf = encode res.(2)} 
            | 2 ->
               if morphs.(0).[0] = '#' then
                  let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
                  {pre = encode res.(0); stm = encode res.(1); suf = [||]}
               else if morphs.(1).[S.length morphs.(1) - 1] = '#' then
                  let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
                  {pre = [||]; stm = encode res.(0); suf = encode res.(1)}
               else begin
                  A.print id morphs;
                  failwith "prefix and suffix should be marked"
               end
            | 1 ->
               let res = (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs.(0) in
               {pre = [||]; stm = encode res; suf = [||]}
            | _ ->
               A.print id morphs;
               failwith "should have no greater than three morphs"
      in
      let fields = S.nsplit (S.strip ln) "\t" in
      if L.length fields > 1 then begin
         let _, true_word_ug = S.split (L.hd fields) " " in
         let true_words_hb = L.map (proc_word encode_hb) (L.tl fields) in
         {  true_word_ug      = proc_word encode_ug true_word_ug; 
            true_words_hb     = true_words_hb; 
            true_pos          = default_pos;
            true_cog          = true;
            segments_ug       = get_segmentations (encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'));
            word_hb           = {pre = [||]; stm = [||]; suf = [||]};
            word_ug           = proc_word encode_ug (S.strip init_segs.(i));
            pos               = default_pos;
            cog               = true;
            cog_prob          = -1.0;
            best_ug           = {pre = [||]; stm = [||]; suf = [||]};
            best_hb           = {pre = [||]; stm = [||]; suf = [||]};
            best_pos          = default_pos;
            best_cog          = true;
            best_prob         = -1.0;
            xxx               = false;
            pre_ed   = [];
            stm_ed   = [];
            suf_ed   = []; }
      end else (* not a cognate *)
         let _, true_word_ug = S.split (L.hd fields) " " in
         {  true_word_ug      = {pre = [||]; stm = encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'); suf = [||]};
            true_words_hb     = [];
            true_pos          = default_pos;
            true_cog          = false;
            segments_ug       = get_segmentations (encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'));
            word_hb           = {pre = [||]; stm = [||]; suf = [||]};
            word_ug           = proc_word encode_ug (S.strip init_segs.(i));
            pos               = default_pos;
            cog               = false;
            cog_prob          = -1.0;
            best_ug           = {pre = [||]; stm = [||]; suf = [||]};
            best_hb           = {pre = [||]; stm = [||]; suf = [||]};
            best_pos          = default_pos;
            best_cog          = false;
            best_prob         = -1.0;
            xxx               = false;
            pre_ed   = [];
            stm_ed   = [];
            suf_ed   = []; }
   in
   (* let data          = A.slice ~last:50 (array_of_file (datadir ^ ug_data)) in *)
   let data          = array_of_file (datadir ^ ug_data) in
   assert (A.length data = A.length init_segs);
   (* let entries       = A.mapi proc_ln (A.slice ~last:50 (array_of_file (datadir ^ ug_data))) in *)
   let entries       = A.mapi proc_ln (array_of_file (datadir ^ ug_data)) in
   let num_hb_chr    = Ht.length hb_of_int - 1 in
   let num_ug_chr    = Ht.length ug_of_int - 1 in
   
   let poses = array_of_file (datadir ^ pos_list) in
   let fsas = Ht.init poses (fun pos -> 
      {  pre_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"pre_" ^ pos ^ ".fsa_bin"))));
         stm_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"stm_" ^ pos ^ ".fsa_bin"))));  
         suf_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"suf_" ^ pos ^ ".fsa_bin")))); }) in
               
   let edits   = L.of_enum [? (Sub (u,h)) | u <- 1 -- num_ug_chr; h <- 1 -- num_hb_chr] @
                 L.of_enum [? (Del u) | u <- 1 -- num_ug_chr] @
                 L.of_enum [? (Ins h) | h <- 1 -- num_hb_chr] @ [End] in
   
   let edit_count    = Ht.create 5000 in
   let mapping       = get_mapping (datadir ^ mapping_file) in
   let mapping2      = get_mapping2 (datadir ^ mapping_file2) in
   let gammas        = Ht.create 5000 in
   L.iter 
      (fun e ->
         match e with 
         | Sub (u,h) -> let b = (L.hd mapping.(u) = h || L.hd mapping2.(h) = u) in Ht.add gammas e b
         | Ins h -> let h' = decode_hb_chr h in let b = (h' = 'y' || h' = 'w') in Ht.add gammas e b
         | _ -> Ht.add gammas e false)
      edits; 
   let pre_count = Ht.create 500 in
   let stm_count = Ht.create 3000 in
   let suf_count = Ht.create 500 in
   foreach (A.enum entries) (begin fun e ->
      foreach (A.enum poses) (begin fun pos ->
         let pre_key = e.word_ug.pre, pos in
         let stm_key = e.word_ug.stm, pos in
         let suf_key = e.word_ug.suf, pos in
         if not (Ht.mem pre_count pre_key) then
            Ht.add pre_count pre_key (Ht.create 200);
         if not (Ht.mem stm_count stm_key) then
            Ht.add stm_count stm_key (Ht.create 200);
         if not (Ht.mem suf_count suf_key) then
            Ht.add suf_count suf_key (Ht.create 200)
      end);
      let pre_key = e.word_ug.pre, e.pos in
      let stm_key = e.word_ug.stm, e.pos in
      let suf_key = e.word_ug.suf, e.pos in
      Ht.incr' (Ht.find pre_count pre_key) e.pre_ed;
      Ht.incr' (Ht.find stm_count stm_key) e.stm_ed;
      Ht.incr' (Ht.find suf_count suf_key) e.suf_ed
   end);
   
   {  encode_ug_chr  = encode_ug_chr;
      decode_ug_chr  = decode_ug_chr;
      encode_hb_chr  = encode_hb_chr;
      decode_hb_chr  = decode_hb_chr;  
      encode_ug      = encode_ug;
      decode_ug      = decode_ug;
      encode_hb      = encode_hb;
      decode_hb      = decode_hb;
      entries        = entries;
      n              = foi (A.length entries) -. 1.;
      fsas           = fsas;
      poses          = poses;
      mapping        = mapping;
      mapping2       = mapping2;
      num_hb_chr     = num_hb_chr;
      num_ug_chr     = num_ug_chr;
      edit_count     = edit_count;
      pre_count      = pre_count;
      stm_count      = stm_count;
      suf_count      = suf_count;
      pos_count      = (let h = Ht.create 10 in (A.iter (fun e -> Ht.incr' h e.pos) entries); h); 
      pre_sum        = (let h = Ht.create 500 in (A.iter (fun e -> Ht.incr' h (e.word_ug.pre,e.pos)) entries); h); 
      stm_sum        = (let h = Ht.create 500 in (A.iter (fun e -> Ht.incr' h (e.word_ug.stm,e.pos)) entries); h);
      suf_sum        = (let h = Ht.create 500 in (A.iter (fun e -> Ht.incr' h (e.word_ug.suf,e.pos)) entries); h);
      edits          = edits;
      gammas         = gammas;
      edit_sum       = Ht.fold (fun _ c acc -> acc +. c) edit_count 0.;
      alphas_sum     = Ht.fold (fun ed b acc -> acc +. (match ed with 
            | Sub _ -> if b then gamma_sub_true else gamma_sub_false 
            | Ins _ -> if b then gamma_ins_true else gamma_ins_false
            | Del _ -> if b then gamma_del_true else gamma_del_false
            | End -> 1.0)) gammas 0.;
   }
;;
let d = read_ugaritic_data "ugaritic.data" "init_none" "hb_letters" "ug_letters" "poses.list" "mapping" "mapping2";;
let get_morph_counts morph mtype pos = 
   let outer_ht = match mtype with Pre -> d.pre_count | Stm -> d.stm_count | Suf -> d.suf_count in
   let key = (morph, pos) in
   if not (Ht.mem outer_ht key) then Ht.add outer_ht key (Ht.create 200); 
   Ht.find outer_ht key
;;   
let rec edit_dist (s1 : string) (s2 : string) =
   (** computes the edit distance (Levenshtein) between two strings *)
  if s1 = "" then S.length s2 else 
    if s2 = "" then S.length s1 else
      let sub_cost = if s1.[0] = s2.[0] then 0 else 1 in
      let sub1, sub2 = S.slice ~first:1 s1, S.slice ~first:1 s2 in
      min (sub_cost + edit_dist sub1 sub2)
		  (min (1 + edit_dist sub1 s2) (1 + edit_dist s1 sub2))
;;
let string_of_edit = function 
   | End -> "End"
   | Ins x -> "Ins " ^ soc (d.decode_hb_chr x)
   | Del x -> "Del " ^ soc (d.decode_ug_chr x)
   | Sub (x,y) -> "Sub " ^ soc (d.decode_ug_chr x) ^ " " ^ soc (d.decode_hb_chr y)
;;
let edit_print out e = S.print out (string_of_edit e);;
let edit_printer paren = edit_print;;
let morph_to_string decode morf = 
   begin try
      let pre = decode morf.pre in
      let stm = decode morf.stm in
      let suf = decode morf.suf in
      if pre <> "" && suf <> "" then
         pre ^ "-" ^ stm ^ "-" ^ suf
      else if pre <> "" && suf = "" then
         pre ^ "-" ^ stm
      else if pre = "" && suf <> "" then
         stm ^ "-" ^ suf
      else stm
   with e -> Array.print (int_printer false) stdout morf.pre; 
             Array.print (int_printer false) stdout morf.stm;
             Array.print (int_printer false) stdout morf.suf;
             raise e
   end
;;
let entry_to_string entry =
   let cog_prob = entry.cog_prob *. foi (A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf) in
   let hb = if entry.true_cog 
               then S.concat " " (L.map (morph_to_string d.decode_hb) entry.true_words_hb)
               else "XXX" in
   morph_to_string d.decode_ug entry.word_ug ^ " (" ^ entry.pos ^ ")\t" ^ 
   morph_to_string d.decode_hb entry.word_hb ^ "\t" ^ hb ^ "\t" ^ (sof cog_prob)   
;;
let entry_to_string_best entry =
   let best_prob = entry.best_prob *. foi (A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf) in
   let hb = if entry.true_cog 
               then S.concat " " (L.map (morph_to_string d.decode_hb) entry.true_words_hb)
               else "XXX" in
   morph_to_string d.decode_ug entry.best_ug ^ " (" ^ entry.best_pos ^")\t" ^ 
   morph_to_string d.decode_hb entry.best_hb ^ "\t" ^ hb ^ "\t" ^ (sof best_prob)
;;
let printer_entry k x = k (fun oc -> IO.nwrite oc (entry_to_string x));;
let entry_print out entry = IO.nwrite out (entry_to_string entry);;
let entry_print_best out entry = IO.nwrite out (entry_to_string_best entry);;
let hb_from_edits edit_list = 
   aol $ L.map_filter (function Ins h -> Some h | Sub (u,h) -> Some h | _ -> None) edit_list
;;
let get_alpha ed = 
   match ed with
   | Sub _ -> if Ht.find d.gammas ed then gamma_sub_true else gamma_sub_false
   | Ins _ -> if Ht.find d.gammas ed then gamma_ins_true else gamma_ins_false
   | Del _ -> if Ht.find d.gammas ed then gamma_del_true else gamma_del_false
   | End   -> 1.0
;;
let edit_to_int = function
   | End -> 0;
   | Ins hb -> hb;
   | Del ug -> d.num_hb_chr + ug
   | Sub (ug,hb) -> 
      d.num_hb_chr + d.num_ug_chr + ((d.num_hb_chr + 1) * ug + hb)
;;
let int_to_edit = function
   | 0 -> End
   | n when n <= d.num_hb_chr -> Ins n
   | n when n <= d.num_hb_chr + d.num_ug_chr -> Del (n - d.num_hb_chr)
   | n -> 
      let n' = n - d.num_hb_chr - d.num_ug_chr in
      let ug = n' / (d.num_hb_chr + 1) in
      let hb = n' mod (d.num_hb_chr + 1) in
      Sub (ug,hb)
;;
let edit_prob edit =
   let alpha = get_alpha edit in
   let edit_count = Ht.count' d.edit_count edit in
   assert (edit_count >= 0.0);
<<<<<<< .mine
   if !temp_anneal then
       ((alpha +. edit_count) /. (d.alphas_sum +. d.edit_sum)) ** schedule.(!r)
    else
       ((alpha +. edit_count) /. (d.alphas_sum +. d.edit_sum))
=======
   (alpha +. edit_count) /. (d.alphas_sum +. d.edit_sum)
>>>>>>> .r1019
;;
let edit_prob_c n = 
   let edit = int_to_edit n in
   -.log (edit_prob edit)
;; 
let asc_fact par count =
   let fact = ref 0.0 in
   for i = 0 to iof count - 1 do
      fact := !fact +. log (par +. foi i)
   done;
   !fact
;;
let adjust probs = 
   let mx = max_item probs in
   let k = 10. /. mx in
   A.update (fun v -> v *. k) probs
;;
   
let construct_fsa ug_morph =
   (* just removed the possibility of deletions... let's see what happens *)
   let fsa, start_state = Fst.new_fst (mtrng) in
   (* let eps_label = 0 in *)
   let ins_labels = L.range 1 (d.num_hb_chr + 1) in
   let ins_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels in
   L.iter2 (fun state label -> 
<<<<<<< .mine
      let ins_prob = log (edit_prob (Ins label)) in
=======
      let ins_prob = -.log (edit_prob (Ins label)) in
>>>>>>> .r1019
      Fst.add_arc fsa start_state state label ins_prob)
      ins_states ins_labels;
   let swap_states = ref [start_state] in
   let spec_states = ref ins_states in
   for i = 0 to A.length ug_morph - 1 do
      let c          = ug_morph.(i) in
      let labels     = d.mapping.(c) in
      (* let del_state  = Fst.add_state fsa (edit_to_int (Del c)) in
      let del_prob   = -.log (edit_prob (Del c)) in
      L.iter (fun swap_state -> Fst.add_arc fsa swap_state del_state eps_label del_prob) !swap_states; *)
      let new_swap_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Sub (c,label)))) labels in
      L.iter2 (fun state label ->
<<<<<<< .mine
         let swap_prob = -. log (edit_prob (Sub (c,label))) in
=======
         let swap_prob = -.log (edit_prob (Sub (c,label))) in
>>>>>>> .r1019
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label swap_prob) !swap_states;
         L.iter (fun spec_state -> Fst.add_arc fsa spec_state state label swap_prob) !spec_states)
         new_swap_states labels;
      let new_ins_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels in
      L.iter2 (fun state label ->
<<<<<<< .mine
         let ins_prob = -. log (edit_prob (Ins label)) in
=======
         let ins_prob = -.log (edit_prob (Ins label)) in
>>>>>>> .r1019
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label ins_prob) new_swap_states)
         new_ins_states ins_labels;
      swap_states := new_swap_states;
      (* spec_states := del_state :: new_ins_states *)
      spec_states := new_ins_states
   done;
<<<<<<< .mine
   let end_prob = -. log (edit_prob End) in
=======
   let end_prob = -.log (edit_prob End) in
>>>>>>> .r1019
   L.iter (fun swap_state -> Fst.set_final fsa swap_state end_prob) !swap_states;
   L.iter (fun spec_state -> Fst.set_final fsa spec_state end_prob) !spec_states;
   fsa
;;
let get_fsa ug_morph pos mtype =
   let key = (ug_morph,pos,mtype) in
   if Ht.mem fsa_cache key then begin
      let fsa = Ht.find fsa_cache key in
      Fst.reweight_fsa fsa; 
      fsa
   end else begin
      let fsa_ = construct_fsa ug_morph in
      let fsa = match mtype with
         | Pre -> Fst.intersect fsa_ (Ht.find d.fsas pos).pre_fsa
         | Stm -> Fst.intersect fsa_ (Ht.find d.fsas pos).stm_fsa
         | Suf -> Fst.intersect fsa_ (Ht.find d.fsas pos).suf_fsa in
      Ht.add fsa_cache key fsa; fsa
   end
;;

let gammas_prior () = 
   (* returns log-prob ignoring the normalization constant *)
   let res = ref 0. in
   let del_count = ref 0 in
   let ins_count = ref 0 in
   let subug_counts = A.make d.num_ug_chr 0 in
   let subhb_counts = A.make d.num_hb_chr 0 in
   for u = 1 to d.num_ug_chr do
      for h = 1 to d.num_hb_chr do 
         if Ht.find d.gammas (Sub (u,h)) then begin
            subug_counts.(u-1) <- subug_counts.(u-1) + 1;
            subhb_counts.(h-1) <- subhb_counts.(h-1) + 1;
         end
      done
   done;      
   for u = 1 to d.num_ug_chr do   (* for deletions *)
      if Ht.find d.gammas (Del u) then del_count := !del_count + 1
   done;
   for h = 1 to d.num_hb_chr do  (* for insertions *)
      if Ht.find d.gammas (Ins h) then ins_count := !ins_count + 1
   done;
   drintf p"";
   drintf p"insert count : %d" !ins_count;
   drintf p"delete count : %d" !del_count;
   drintf p"ug sub count : %{int array}" subug_counts;
   drintf p"hb sub count : %{int array}" subhb_counts;
   
   res := !res +. (if !del_count < A.length del_lp then del_lp.(!del_count) else neg_infinity);
   res := !res +. (if !ins_count < A.length ins_lp then ins_lp.(!ins_count) else neg_infinity);
   foreach (A.enum subug_counts) (fun c -> 
      res := !res +. (if c < A.length subug_lp then subug_lp.(c) else neg_infinity));
   foreach (A.enum subhb_counts) (fun c ->
      res := !res +. (if c < A.length subhb_lp then subhb_lp.(c) else neg_infinity));
   !res
;;
let swap_ug u h =
   Ht.replace d.gammas (Sub (u,h)) false;
   
   let probs = A.make d.num_hb_chr neg_infinity in
   for h' = 1 to d.num_hb_chr do
      let edit  = Sub (u,h') in
      if Ht.find d.gammas edit = false then begin
         let others = ref 0 in
         for u' = 1 to d.num_ug_chr do
            if Ht.find d.gammas (Sub (u',h')) then incr others
         done;
         let count    = Ht.count' d.edit_count edit in
         let pr_true  = if (!others+1) < A.length subhb_lp then subhb_lp.(!others+1) else neg_infinity in
         let pr_false = if (!others) < A.length subhb_lp then subhb_lp.(!others) else neg_infinity in
         let ll_true  = asc_fact gamma_sub_true count in
         let ll_false = asc_fact gamma_sub_false count in
         probs.(h'-1) <- ll_true +. pr_true -. ll_false -. pr_false
      end
   done;
   A.update exp probs;
<<<<<<< .mine
   adjust probs;
   if anneal then A.update (fun v -> v ** schedule.(!r)) probs;
=======
   (* A.print sof probs; *)
>>>>>>> .r1019
   let resi = ref (-1) in
   begin try 
      let i = A.findi (fun v -> v = infinity) probs in
      resi := i
   with Not_found -> begin
      let sum = A.sum probs in
      let rn = Fst.random mtrng sum in
      let accum = ref 0.0 in
      begin try
         A.iteri (fun i prb ->
            accum := !accum +. prb;
            if rn < !accum then begin
               resi := i;
               raise Done
            end) probs;
      with Done -> () end
   end end;
   assert (!resi <> (-1));
   
   let new_h = !resi + 1 in
   Ht.replace d.gammas (Sub (u,new_h)) true
;;
let swap_hb h u =
   Ht.replace d.gammas (Sub (u,h)) false;
   
   let probs = A.make d.num_ug_chr neg_infinity in
   for u' = 1 to d.num_ug_chr do
      let edit  = Sub (u',h) in
      if Ht.find d.gammas edit = false then begin
         let others = ref 0 in
         for h' = 1 to d.num_hb_chr do
            if Ht.find d.gammas (Sub (u',h')) then incr others
         done;
         let count    = Ht.count' d.edit_count edit in
         let pr_true  = if (!others+1) < A.length subug_lp then subug_lp.(!others+1) else neg_infinity in
         let pr_false = if (!others) < A.length subug_lp then subug_lp.(!others) else neg_infinity in
         let ll_true  = asc_fact gamma_sub_true count in
         let ll_false = asc_fact gamma_sub_false count in
         probs.(u'-1) <- ll_true +. pr_true -. ll_false -. pr_false
      end
   done;
   A.update exp probs;
<<<<<<< .mine
   adjust probs;
   if anneal then A.update (fun v -> v ** schedule.(!r)) probs;
=======
   (* A.print sof probs; *)
>>>>>>> .r1019
   let resi = ref (-1) in
   begin try 
      let i = A.findi (fun v -> v = infinity) probs in
      resi := i
   with Not_found -> begin
      let sum = A.sum probs in
      let rn = Fst.random mtrng sum in
      let accum = ref 0.0 in
      begin try
         A.iteri (fun i prb ->
            accum := !accum +. prb;
            if rn < !accum then begin
               resi := i;
               raise Done
            end) probs;
      with Done -> () end
   end end;
   assert (!resi <> (-1));
   
   let new_u = !resi + 1 in
   Ht.replace d.gammas (Sub (new_u,h)) true
;;
let swap_ins h = 
   Ht.replace d.gammas (Ins h) false;
   
   let probs = A.make d.num_hb_chr neg_infinity in
   for h' = 1 to d.num_hb_chr do
      let edit = Ins h' in
      if Ht.find d.gammas edit = false then begin
         let count = Ht.count' d.edit_count edit in
         let ll_true = asc_fact gamma_ins_true count in
         let ll_false = asc_fact gamma_ins_false count in
         probs.(h'-1) <- ll_true -. ll_false
      end
   done;
   A.update exp probs;
<<<<<<< .mine
   adjust probs;
   if anneal then A.update (fun v -> v ** schedule.(!r)) probs;
=======
>>>>>>> .r1019
   let resi = ref (-1) in
   let sum = A.sum probs in
   let rn = Fst.random mtrng sum in
   let accum = ref 0. in
   begin try
      A.iteri (fun i prb ->
         accum := !accum +. prb;
         if rn < !accum then begin
            resi := i;
            raise Done
         end) probs;
   with Done -> () end;
   assert (!resi <> (-1));
   
   let new_h = !resi + 1 in
   Ht.replace d.gammas (Ins new_h) true
;;      
let swap_del u = 
   Ht.replace d.gammas (Del u) false;
   
   let probs = A.make d.num_ug_chr neg_infinity in
   for u' = 1 to d.num_ug_chr do
      let edit = Del u' in
      if Ht.find d.gammas edit = false then begin
         let count = Ht.count' d.edit_count edit in
         let ll_true = asc_fact gamma_ins_true count in
         let ll_false = asc_fact gamma_ins_false count in
         probs.(u'-1) <- ll_true -. ll_false
      end
   done;
   A.update exp probs;
<<<<<<< .mine
   adjust probs;
   if anneal then A.update (fun v -> v ** schedule.(!r)) probs;
=======
>>>>>>> .r1019
   let resi = ref (-1) in
   let sum = A.sum probs in
   let rn = Fst.random mtrng sum in
   let accum = ref 0. in
   begin try
      A.iteri (fun i prb ->
         accum := !accum +. prb;
         if rn < !accum then begin
            resi := i;
            raise Done
         end) probs;
   with Done -> () end;
   assert (!resi <> (-1));
   
   let new_u = !resi + 1 in
   Ht.replace d.gammas (Del new_u) true
;;      
let sample_gamma edit =
   (* _DEBUG := true; *)
   drintf p"\nSAMPLING edit = %{edit}" edit;
   drintf p"============================";
   let old_alpha = get_alpha edit in
   d.alphas_sum <- d.alphas_sum -. old_alpha;

   let count      = Ht.count' d.edit_count edit in
   assert (count >= 0.0);
   let all_count  = d.edit_sum in
   assert (all_count >= 0.0);
   
   drintf p"   true?\n";
   Ht.replace d.gammas edit true;
   let alpha_true = get_alpha edit in
   let ll_true    = asc_fact alpha_true count -. asc_fact (d.alphas_sum +. alpha_true) all_count in
   let pr_true    = gammas_prior () +. ll_true in

   drintf p"\n   false?\n";
   Ht.replace d.gammas edit false;
   let alpha_false = get_alpha edit in
   let ll_false   = asc_fact alpha_false count -. asc_fact (d.alphas_sum +. alpha_false) all_count in
   let pr_false   = gammas_prior () +. ll_false in
   
   begin try assert (pr_true <> neg_infinity || pr_false <> neg_infinity)
      with e -> edit_print stdout edit; raise e end;
   let z = if pr_true = neg_infinity then pr_false else if pr_false = neg_infinity then pr_true else min pr_true pr_false in
   assert (z > neg_infinity && z < infinity);
   drintf p"pr_false = %f" pr_false;
   drintf p"pr_true  = %f" pr_true;
   drintf p"z = %f" z;
   let a = [|exp (pr_false -. z); exp (pr_true -. z)|] in
   assert (A.for_all (fun n -> n <> neg_infinity & n <> infinity) a);
<<<<<<< .mine
   adjust a;
   if anneal then A.update (fun v -> v ** schedule.(!r)) a;
=======
   drintf p"%{float array}" a;
   drintf p"sampling....";
   drintf p"%{float array}" a;
>>>>>>> .r1019
   let i = sample_discrete a in
   drintf p"sampled!";
   if i = 1 then begin
      drintf p"   true!";
      Ht.replace d.gammas edit true;
      d.alphas_sum <- d.alphas_sum +. alpha_true
   end else begin
      drintf p"   false!";
      Ht.replace d.gammas edit false; 
      d.alphas_sum <- d.alphas_sum +. alpha_false
   end
;;

let decrement_entry_counts entry i =
   let opos = entry.pos in
   let opre = entry.word_ug.pre in
   let ostm = entry.word_ug.stm in
   let osuf = entry.word_ug.suf in

   let pre_count = get_morph_counts opre Pre opos in
   let stm_count = get_morph_counts ostm Stm opos in
   let suf_count = get_morph_counts osuf Suf opos in

   if Ht.count' pre_count entry.pre_ed = 1.0 then
      L.iter (fun ed -> Ht.decr' d.edit_count ed; d.edit_sum <- d.edit_sum -. 1.) entry.pre_ed;
   if Ht.count' stm_count entry.stm_ed = 1.0 then
      L.iter (fun ed -> Ht.decr' d.edit_count ed; d.edit_sum <- d.edit_sum -. 1.) entry.stm_ed;
   if Ht.count' suf_count entry.suf_ed = 1.0 then
      L.iter (fun ed -> Ht.decr' d.edit_count ed; d.edit_sum <- d.edit_sum -. 1.) entry.suf_ed;
   Ht.decr' pre_count entry.pre_ed;
   Ht.decr' stm_count entry.stm_ed;
   Ht.decr' suf_count entry.suf_ed;
   Ht.decr' d.pre_sum (opre,opos);
   Ht.decr' d.stm_sum (ostm,opos);
   Ht.decr' d.suf_sum (osuf,opos);
   Ht.decr' d.pos_count opos;
   assert (Ht.find pre_count entry.pre_ed >= 0.);
   assert (Ht.find stm_count entry.stm_ed >= 0.);
   assert (Ht.find suf_count entry.suf_ed >= 0.);
   assert (Ht.find d.pre_sum (opre,opos) >= 0.);
   assert (Ht.find d.stm_sum (ostm,opos) >= 0.);
   assert (Ht.find d.suf_sum (osuf,opos) >= 0.);
   assert (Ht.find d.pos_count opos >= 0.);
;;
let increment_pos_counts entry = 
   (* increment counts *)
   let npos = entry.pos in
   let nseg = entry.word_ug in
   Ht.incr' d.pos_count npos;
   Ht.incr' d.pre_sum (nseg.pre,npos);
   Ht.incr' d.stm_sum (nseg.stm,npos);
   Ht.incr' d.suf_sum (nseg.suf,npos);
   if not (Ht.mem d.pre_count (nseg.pre,npos)) then Ht.add d.pre_count (nseg.pre,npos) (Ht.create 200);
   if not (Ht.mem d.stm_count (nseg.stm,npos)) then Ht.add d.stm_count (nseg.stm,npos) (Ht.create 200);
   if not (Ht.mem d.suf_count (nseg.suf,npos)) then Ht.add d.suf_count (nseg.suf,npos) (Ht.create 200);
;;
let increment_mrf_counts entry mtype =
   let nmorf   = match mtype with Pre -> entry.word_ug.pre  | Stm -> entry.word_ug.stm    | Suf -> entry.word_ug.suf in
   let nedits  = match mtype with Pre -> entry.pre_ed       | Stm -> entry.stm_ed         | Suf -> entry.suf_ed in
   let mrf_counts = get_morph_counts nmorf mtype entry.pos in
   
   if Ht.count' mrf_counts nedits = 0.0 then
      L.iter (fun ed -> Ht.incr' d.edit_count ed; d.edit_sum <- d.edit_sum +. 1.) nedits;
   Ht.incr' mrf_counts nedits;
;;

let best_morphs ug_word pos =
   (* for a given segmentation and pos, returns the highest prob (hebrew morph, prob) *)
   let pre = ug_word.pre in
   let stm = ug_word.stm in
   let suf = ug_word.suf in
   let pre_fsa = get_fsa pre pos Pre in
   let stm_fsa = get_fsa stm pos Stm in
   let suf_fsa = get_fsa suf pos Suf in
   let pre_count = get_morph_counts pre Pre pos in
   let stm_count = get_morph_counts stm Stm pos in
   let suf_count = get_morph_counts suf Suf pos in
   let get_possible counts fsa = 
      let e = Enum.filter_map (fun (el,c) -> if c > 0.0 then Some el else None) (Ht.enum counts) in
      if Obj.magic (Fst.get_start fsa) != -1 then begin
         let fsa_best = L.map int_to_edit (loa (Fst.get_best_edits fsa)) in
         if Ht.count' counts fsa_best = 0.0 then Enum.push e fsa_best
      end;
      A.of_enum e
   in       
   let pres = get_possible pre_count pre_fsa in
   let stms = get_possible stm_count stm_fsa in
   let sufs = get_possible suf_count suf_fsa in
   let score_morph alpha counts edits =
      let edits_logprob = L.fold_left (fun accum edit -> log (edit_prob edit) +. accum) 0. edits in
      exp (10. +. edits_logprob) /. (d.n +. alpha)  +.  (10. *. (Ht.count' counts edits /. (d.n +. alpha)))
   in
   let pre_probs = A.map (score_morph alpha_pre pre_count) pres in
   let stm_probs = A.map (score_morph alpha_stm stm_count) stms in
   let suf_probs = A.map (score_morph alpha_suf suf_count) sufs in
   if L.exists (fun a -> A.length a = 0) [pre_probs; stm_probs; suf_probs] then
      ({pre=[||]; stm=[||]; suf=[||]}, 0.0)
   else begin
      let pre_i, pre_prob = max_itemi pre_probs in
      let stm_i, stm_prob = max_itemi stm_probs in
      let suf_i, suf_prob = max_itemi suf_probs in
      ({ pre = hb_from_edits pres.(pre_i); 
         stm = hb_from_edits stms.(stm_i);
         suf = hb_from_edits sufs.(suf_i)},
       pre_prob *. stm_prob *. suf_prob)
    end
;;
let best_prediction entry =
   (* decrement_entry_counts entry; *)
   let num_segs = A.length entry.segments_ug in
   let num_pos = A.length d.poses in
   let probs = A.make (num_segs * num_pos) 0. in
   let words = A.make (num_segs * num_pos) ({pre=[||];stm=[||];suf=[||]},{pre=[||];stm=[||];suf=[||]},"") in
   for i = 0 to A.length probs - 1 do
      let pos = d.poses.(i mod num_pos) in
      let seg = entry.segments_ug.(i / num_pos) in
      let w,p = best_morphs seg pos in
      probs.(i) <- p;
      words.(i) <- (seg, w, pos)
   done;
   let resi, best_prob = max_itemi probs in
   let best_ug, best_hb, best_pos = words.(resi) in
   entry.best_prob <- best_prob;
   entry.best_ug  <- best_ug;
   entry.best_hb  <- best_hb;
   entry.best_pos <- best_pos;
   (* increment_pos_counts entry;
   increment_mrf_counts entry Pre;
   increment_mrf_counts entry Stm;
   increment_mrf_counts entry Suf; *)
;;

let segmentation_prob ug_word pos ~init = 
   (* XXX (or not) NOTE: currently uses Fst.get_best in place of the more technically correct Fst.get_beta *)
   let pre = ug_word.pre in
   let stm = ug_word.stm in
   let suf = ug_word.suf in
   let pre_fsa = get_fsa pre pos Pre in
   let stm_fsa = get_fsa stm pos Stm in
   let suf_fsa = get_fsa suf pos Suf in
   let log_beta_pre = -.Fst.get_beta pre_fsa in
   let log_beta_stm = -.Fst.get_beta stm_fsa in
   let log_beta_suf = -.Fst.get_beta suf_fsa in
   if init then
      exp (10. +. log_beta_pre +. log_beta_stm +. log_beta_suf)
   else begin
      let pre_n'  = Ht.count' d.pre_sum (pre,pos) in
      let stm_n'  = Ht.count' d.stm_sum (stm,pos) in
      let suf_n'  = Ht.count' d.suf_sum (suf,pos) in
      let n       = Ht.count' d.pos_count pos in
      assert (pre_n' >= 0.);
      assert (stm_n' >= 0.);
      assert (suf_n' >= 0.);
      ((exp 20.) *. (pre_n' /. (n +. alpha_pre)) +. exp (20. +. (log alpha_pre +. log_beta_pre) -. log (n +. alpha_pre))) *.
      ((exp 20.) *. (stm_n' /. (n +. alpha_stm)) +. exp (20. +. (log alpha_stm +. log_beta_stm) -. log (n +. alpha_stm))) *.
      ((exp 20.) *. (suf_n' /. (n +. alpha_suf)) +. exp (20. +. (log alpha_suf +. log_beta_suf) -. log (n +. alpha_suf)))
   end
;;
let sample_hb_mrf entry mtype ~init i =
   (* ASSUMES THAT CALLING FUNCTION TAKES CARE OF INCREMENT/DECREMENT COUNTS! *)
   let t = if anneal then schedule.(!r) else 1. in
   let pos        = entry.pos in
   let ug_mrf     = match mtype with Pre -> entry.word_ug.pre  | Stm -> entry.word_ug.stm | Suf -> entry.word_ug.suf in
   let alpha      = match mtype with Pre -> alpha_pre          | Stm -> alpha_stm         | Suf -> alpha_suf in
   let mrf_counts = get_morph_counts ug_mrf mtype pos in
   let n' = match mtype with
      | Pre -> Ht.find d.pre_sum (ug_mrf,pos)
      | Stm -> Ht.find d.stm_sum (ug_mrf,pos)
      | Suf -> Ht.find d.suf_sum (ug_mrf,pos) in
   assert (n' >= 0.);
   let fsa = get_fsa ug_mrf pos mtype in
<<<<<<< .mine
   temp_anneal := false;

=======
   let n = d.n in
>>>>>>> .r1019
   let beta = exp (-.Fst.get_beta fsa) in
   (* assert (beta > 0.0); *)
<<<<<<< .mine
   let sum = (n' ** t)  +.  ((alpha ** t) *. beta) in  
=======
   let sum = (n' /. (n +. alpha)) +. ((alpha *. beta) /. (n +. alpha)) in
>>>>>>> .r1019
   (* sample random number -- set to infinity if initializing, so base distribution will be sampled *)
   let rn = if init then infinity else Fst.random mtrng sum in
   let p = ref 0.0 in
   let edits = ref [] in
   begin try 
      (* try to sample from an existing 'table' *)
      foreach (Ht.enum mrf_counts) (fun (edit_list,c) -> 
         assert (c >= 0.0);
<<<<<<< .mine
         let prob = c ** t in
         accum := !accum +. prob;
         if rn < !accum then begin
=======
         p := !p +. c /. (n +. alpha);
         if rn < !p then begin
>>>>>>> .r1019
            edits := edit_list;
            raise Done
         end);
      (* Didn't sample an existing 'table', so sample from base distribution *)
      let sid = Fst.get_start fsa in
      if Obj.magic sid == -1 then begin
         if mtype = Pre then print_endline "PRE";
         printf p"%d:  trying to sample with sid = -1: ^%s^" i (d.decode_ug ug_mrf)
      end else
         edits := L.map int_to_edit (loa (Fst.sample fsa));
   with Done -> () end;

   let hb_mrf = hb_from_edits !edits in
   match mtype with 
      | Pre -> entry.pre_ed <- !edits; entry.word_hb.pre <- hb_mrf
      | Stm -> entry.stm_ed <- !edits; entry.word_hb.stm <- hb_mrf
      | Suf -> entry.suf_ed <- !edits; entry.word_hb.suf <- hb_mrf
;;
let sample_entry entry ~init i = 
   decrement_entry_counts entry i;
   
   (* first sample new segmentation/pos *)
   let num_segs = A.length entry.segments_ug in
   let num_pos = A.length d.poses in
   let probs = A.init (num_segs * num_pos) 
      (fun j ->
         let pos = d.poses.(j mod num_pos) in
         let seg = entry.segments_ug.(j / num_pos) in
         segmentation_prob seg pos ~init) in
<<<<<<< .mine
   adjust probs;
   if anneal then (let t = schedule.(!r) in A.update (fun v -> v ** t) probs);
   assert (A.for_all (fun p -> p >= 0. && p < infinity) probs);
=======
>>>>>>> .r1019
   let prob_sum = A.sum probs in
   entry.cog_prob <- prob_sum;
   if prob_sum > 0. then begin
      let rn = Fst.random mtrng prob_sum in
      let accum = ref 0.0 in
      let resi = ref (-1) in
      begin try
         A.iteri (fun j prob ->
            accum := !accum +. prob;
            if rn < !accum then begin
               resi := j;
               raise Done
            end) 
         probs;
      with Done -> () end;
      
      assert (!resi <> (-1));
      let npos = d.poses.(!resi mod num_pos) in
      let nseg = entry.segments_ug.(!resi / num_pos) in

      entry.word_ug <- nseg;
      entry.pos <- npos;

      increment_pos_counts entry;
      
      sample_hb_mrf entry Pre ~init i;
      increment_mrf_counts entry Pre;

      sample_hb_mrf entry Stm ~init i;
      increment_mrf_counts entry Stm;

      sample_hb_mrf entry Suf ~init i;
      increment_mrf_counts entry Suf
   end else begin
      printf p"can't sample pos/seg:  %d" i;
      entry.xxx <- true;
      entry.cog <- false;
   end
;;
let sample_entry_init entry i =
   decrement_entry_counts entry i;

   (* try to sample pos without changing init seg *)
   let probs = A.map (fun pos -> segmentation_prob entry.word_ug pos ~init:true) d.poses in
   let prob_sum = A.sum probs in
   if prob_sum > 0. then begin
      let rn = Fst.random mtrng prob_sum in
      let accum = ref 0.0 in
      let resi = ref (-1) in
      begin try
         A.iteri (fun i prob ->
            accum := !accum +. prob;
            if rn < !accum then begin
               resi := i;
               raise Done
            end) 
         probs;
      with Done -> () end;
      
      assert (!resi <> (-1));
      let npos = d.poses.(!resi) in
      entry.pos <- npos;
      
      increment_pos_counts entry;
      
      sample_hb_mrf entry Pre ~init:true i;
      increment_mrf_counts entry Pre;

      sample_hb_mrf entry Stm ~init:true i;
      increment_mrf_counts entry Stm;

      sample_hb_mrf entry Suf ~init:true i;
      increment_mrf_counts entry Suf
   end else begin (* try to find a new segmentation *)
      (* reincrement, to avoid double decrement from call to sample_entry *)
      increment_pos_counts entry;
      increment_mrf_counts entry Pre;
      increment_mrf_counts entry Stm;
      increment_mrf_counts entry Suf;
      sample_entry entry true i
   end
;;
let sample_morphs ~init r =
   let counter = ref 0 in
   (* foreach (A.enum d.entries |> E.filter (fun e -> e.true_cog)) (begin fun entry ->  *)
   foreach (A.enum d.entries) (begin fun entry -> 
      if !counter mod 100 = 0 then
         printf p"sampling morph  %d" !counter;
      incr counter;
      (* if init then 
         sample_entry_init entry !counter
      else  *)
         if not entry.xxx then
         sample_entry entry ~init !counter
   end)
;;

let write_output () =
   File.with_file_out ~mode:[`trunc;`text;`create] "ugaritic.output" 
      (fun out -> Array.print ~first:"" ~last:"\n" ~sep:"\n" entry_print out d.entries);
;;
let write_best () =
   File.with_file_out ~mode:[`trunc;`text;`create] "ugaritic.best" 
      (fun out -> Array.print ~first:"" ~last:"\n" ~sep:"\n" entry_print_best out d.entries);
;;
let write_gammas () =
   File.with_file_out ~mode:[`trunc;`text;`create] "gammas.output"
      (fun out -> 
         let a = Ht.to_array (Ht.filter id d.gammas) in
         A.sort (fun x y -> compare (edit_to_int (fst x)) (edit_to_int (fst y))) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" (tuple2_print ~first:"" ~last:"" ~sep:"\t\t" edit_print Bool.print) out a); 
;;
let write_edit_counts () = 
   let tup_print out (e,c) =
      fprintf out p"%{edit}\t\t%B\t%8d" e (Ht.find d.gammas e) (iof c)
   in
   File.with_file_out ~mode:[`trunc;`text;`create] "edit_counts.output"
      (fun out -> 
         let a = Ht.to_array (Ht.filter (fun c -> c > 0.) d.edit_count) in
         A.sort (fun x y -> compare (edit_to_int (fst x)) (edit_to_int (fst y))) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" tup_print out a); 
;;
let write_morph_counts () =
   let f ht out = 
      let res = Ht.create 20 in
      foreach (Ht.enum ht) (fun ((morph,pos), ht2) ->
         foreach (Ht.enum ht2) (fun (el,c) ->
            let ug_str = d.decode_ug morph in
            let hb_str = d.decode_hb (hb_from_edits el) in
            Ht.add_int res (ug_str,hb_str,pos) (iof c)));
      let a = Ht.to_array (Ht.filter (fun c -> c > 0) res) in
      A.sort (fun x y -> - compare (snd x) (snd y)) a;
      Array.print ~first:"" ~last:"\n" ~sep:"\n"
         (fun out ((ug_str,hb_str,pos), c) -> fprintf out p"%s %s (%s)\t%15d" ug_str hb_str pos c)
         out a
   in
   File.with_file_out ~mode:[`trunc;`text;`create] "pre_counts.output" (f d.pre_count);
   File.with_file_out ~mode:[`trunc;`text;`create] "stm_counts.output" (f d.stm_count);
   File.with_file_out ~mode:[`trunc;`text;`create] "suf_counts.output" (f d.suf_count);
;;

let eval () =
   let pre_er = Ht.create 500 in
   let stm_er = Ht.create 500 in
   let suf_er = Ht.create 500 in
   
   let perfect       = ref 0 in
   let dist_total    = ref 0 in
   
   let perfect_w     = ref 0 in
   let dist_total_w  = ref 0 in
   
   let counter = ref 1 in
   foreach (A.enum d.entries) (begin fun entry ->
      if !counter mod 100 = 0 then 
         printf p"eval: %d" !counter;
      incr counter;
      best_prediction entry;
      if entry.true_cog then begin
         let ug_pre = d.decode_ug entry.best_ug.pre in
         let ug_stm = d.decode_ug entry.best_ug.stm in
         let ug_suf = d.decode_ug entry.best_ug.suf in

         let pre_prd = d.decode_hb entry.best_hb.pre in
         let stm_prd = d.decode_hb entry.best_hb.stm in
         let suf_prd = d.decode_hb entry.best_hb.suf in
         let wrd_prd = pre_prd ^ stm_prd ^ suf_prd in
      
         let pres = L.map (fun w -> d.decode_hb w.pre) entry.true_words_hb in
         let stms = L.map (fun w -> d.decode_hb w.stm) entry.true_words_hb in
         let sufs = L.map (fun w -> d.decode_hb w.suf) entry.true_words_hb in
         let wrds = L.map (fun w -> d.decode_hb w.pre ^ d.decode_hb w.stm ^ d.decode_hb w.suf) entry.true_words_hb in
      
         let pre_dists = L.map (edit_dist pre_prd) pres in
         let stm_dists = L.map (edit_dist stm_prd) stms in
         let suf_dists = L.map (edit_dist suf_prd) sufs in
         let wrd_dists = L.map (edit_dist wrd_prd) wrds in
      
         let prei, pre_dist = L.min_itemi pre_dists in
         let stmi, stm_dist = L.min_itemi stm_dists in
         let sufi, suf_dist = L.min_itemi suf_dists in
         let wrd_dist = L.min wrd_dists in
      
         if pre_dist = 0 then incr perfect else Ht.incr pre_er (ug_pre, pre_prd, L.nth pres prei);
         if stm_dist = 0 then incr perfect else Ht.incr stm_er (ug_stm, stm_prd, L.nth stms stmi);
         if suf_dist = 0 then incr perfect else Ht.incr suf_er (ug_suf, suf_prd, L.nth sufs sufi);
         if wrd_dist = 0 then incr perfect_w;
         dist_total   := !dist_total + pre_dist + stm_dist + suf_dist;
         dist_total_w := !dist_total_w + wrd_dist
      end
   end);
   let n_w = A.count (fun e -> e.true_cog) d.entries in
   let n = n_w * 3 in
   printf p"perfect mrfs  = %f (%d)" (foi !perfect /. foi n) n;
   printf p"avg edit dist = %f" (foi !dist_total /. foi n);
   printf p"perfect wrds  = %f (%d)" (foi !perfect_w /. foi n_w) n_w;
   printf p"avg edit dist = %f" (foi !dist_total_w /. foi n_w);

   let write fn ht =
      File.with_file_out ~mode:[`trunc;`text;`create] fn
      (fun out -> 
         let a = Ht.to_array ht in
         A.sort (fun x y ->  - compare (snd x) (snd y)) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" (tuple2_print ~first:"" ~last:"" ~sep:"\t\t" (tuple3_print S.print S.print S.print) Int.print) out a)
   in
   write "pre.errors" pre_er;
   write "stm.errors" stm_er;
   write "suf.errors" suf_er;
;;
let main () =
   write_gammas ();
   for r = 0 to 10000 do
      printf  p"SAMPLING round = %d" (r+1);
      sample_morphs (r = 0) r;
      printf p"sampled morphs";
      foreach (L.enum d.edits) sample_gamma;
      L.iter (begin fun ed ->
            if Ht.find d.gammas ed then match ed with
               | Sub (u,h) -> swap_ug u h
               | Del u -> swap_del u
               | _ -> ()
         end) d.edits;
      
      L.iter (begin fun ed ->
            if Ht.find d.gammas ed then match ed with
               | Sub (u,h) -> swap_ug u h
               | Ins h -> swap_ins h
               | _ -> ()
         end) d.edits;
      
      if r mod 3 = 2 then begin
         printf p"evaluating...";
         eval ();
         write_best ()
      end;
      write_output ();
      write_gammas ();
      write_edit_counts ();
      write_morph_counts ();
   done
;;

let _ = Callback.register "edit_prob" edit_prob_c;;
if not !Sys.interactive then main ()


let make_entry ug_w =
   let encode = d.encode_ug in
   let morphs_ = S.nsplita ug_w "-" in
   let morphs = match A.length morphs_ with
      | 3 ->
         if not (morphs_.(0).[0] = '#' && morphs_.(2).[S.length morphs_.(2) - 1] = '#') then begin
            A.print id morphs_;
            failwith "prefix and suffix should be marked"
         end;
         let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs_ in
         {pre = encode res.(0); stm = encode res.(1); suf = encode res.(2)} 
      | 2 ->
         if morphs_.(0).[0] = '#' then
            let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs_ in
            {pre = encode res.(0); stm = encode res.(1); suf = [||]}
         else if morphs_.(1).[S.length morphs_.(1) - 1] = '#' then
            let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs_ in
            {pre = [||]; stm = encode res.(0); suf = encode res.(1)}
         else begin
            A.print id morphs_;
            failwith "prefix and suffix should be marked"
         end
      | 1 ->
         let res = (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs_.(0) in
         {pre = [||]; stm = encode res; suf = [||]}
      | _ ->
         A.print id morphs_;
         failwith "should have no greater than three morphs"
   in
   {  true_word_ug = morphs;
      word_ug = morphs;
      true_words_hb = [];
      true_cog = true;
      pos = default_pos;
      cog = true;
      best_pos = default_pos;
      best_cog = true;
      cog_prob = -1.0;
      best_prob = -1.0;
      true_pos = default_pos;
      word_hb  = {pre = [||]; stm = [||]; suf = [||]};
      best_ug  = {pre = [||]; stm = [||]; suf = [||]};
      best_hb  = {pre = [||]; stm = [||]; suf = [||]};
      segments_ug = [||];
      xxx = false;
      pre_ed = [];
      stm_ed = [];
      suf_ed = [];   }
;;