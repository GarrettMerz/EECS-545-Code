open Util, Batteries, Batteries.Standard, Print
module Fst = OpenFst

let _DEBUG = ref true;;
let only_plene = true;;

let start_time = iof (Unix.time ());;
let printf fmt = ksprintf print_endline fmt;;
let drintf fmt = if !_DEBUG then ksprintf print_endline fmt else ifprintf true fmt;;

let rng = Gsl_rng.make (Gsl_rng.default ());;
Random.self_init ();;
let seed = Random.nativeint (Nativeint.of_int max_int);;
Gsl_rng.set rng seed;;
let set_seed n =
  Gsl_rng.set rng (Nativeint.of_int n);
  Random.init n
;;
set_seed 0;;
let mtrng = Fst.new_rng (Nativeint.to_int seed);;
let sample ?(sum=None) probs =
   assert (A.length probs > 0);
   assert (A.for_all (fun v -> v >= 0.) probs);
   let prob_sum = match sum with None -> A.sum probs | Some v -> v in
   let resi = ref (-1) in
   let rn = Fst.random mtrng prob_sum in
   let accum = ref 0.0 in
   begin try
      A.iteri (fun i prb ->
         accum := !accum +. prb;
         if rn < !accum then begin
            resi := i;
            raise Done
         end) probs
   with Done -> () end;
   assert (!resi <> (-1));
   !resi
;;

let datadir = "/afs/csail.mit.edu/u/b/bsnyder/scratch/ugaritic/";;

let cogs             = ref 0
let init             = ref true
let r                = ref 0;;

let params = if A.length Sys.argv = 2 then Some (Ht.of_file id fos Sys.argv.(1)) else None;;
let get_param v s = match params with None -> v | Some ht -> Ht.get ht s v

let cog_prior        = get_param 1.0 "cog_prior"
let gamma_sub_true   = get_param 50.0 "gammas_sub_true"
let gamma_sub_false  = get_param 1.0 "gammas_sub_false"

let gamma_ins_true   = get_param 1.0 "gammas_ins_true" 
let gamma_ins_false  = get_param 1.0 "gammas_ins_false"
let gamma_del_true   = get_param 1.0 "gammas_del_true"
let gamma_del_false  = get_param 1.0 "gammas_del_false"
let ins_prior        = get_param 0.4 "ins_prior"

let alpha_pre        = get_param 0.01 "alpha_pre"
let alpha_stm        = get_param 100.0 "alpha_stm"
let alpha_suf        = get_param 0.01 "alpha_suf"

let rounds           = iof (get_param 100. "rounds")
let hb_budget        = iof (get_param 10. "hb_budget")
let ug_budget        = iof (get_param 10. "ug_budget")
let penalty          = get_param (-10.) "penalty"

let anneal        = false;;
let temp_anneal   = ref false;;
let anneal_begin  = 1.0;;
let anneal_end    = 5.0;; 
let anneal_burn   = 5;;
let schedule =
   let n = rounds - anneal_burn in
      let d = (anneal_end -. anneal_begin) /. (foi n) in 
      A.init rounds (fun i -> if i < anneal_burn then 1. else d *. (foi (i - anneal_burn)) +. anneal_begin)
;;

type fst = Fst.fst 
type edit = Ins of int | Del of int | Sub of (int * int) | End 
type morph = int array 
type pos = string 
type morph_type = Pre | Stm | Suf  
type word = {
   mutable pre   : morph;
   mutable stm   : morph;
   mutable suf   : morph;   } 
;;
type possible = {p_ug : word; p_hb : word; p_pre_ed : edit list; p_stm_ed : edit list; p_suf_ed : edit list; p_pos : string}
type entry = {
   true_word_ug         : word;
   true_words_hb        : word list;
   true_pos             : pos;
   true_cog             : bool;
   segments_ug          : word array;
   pre_tbl              : int Hs.t;
   stm_tbl              : int Hs.t;
   suf_tbl              : int Hs.t;
   mutable all_possible : possible array;
   mutable word_hb      : word;
   mutable word_ug      : word;
   mutable pos          : pos;
   mutable cog          : bool;
   mutable cog_prob     : float;
   mutable xxx          : bool;
   mutable best_hb      : word;
   mutable best_ug      : word;
   mutable best_pos     : pos;
   mutable best_cog     : bool;
   mutable best_prob    : float;
   mutable pre_ed       : edit list;
   mutable stm_ed       : edit list;
   mutable suf_ed       : edit list;   } 
;;
type mapping = int list array
type fsa_record = {pre_fsa : fst; stm_fsa : fst; suf_fsa : fst} 
type data = {
   encode_ug_chr        : char -> int;
   decode_ug_chr        : int -> char;
   encode_hb_chr        : char -> int;
   decode_hb_chr        : int -> char;
   encode_hb            : string -> morph;
   decode_hb            : morph -> string;
   encode_ug            : string -> morph;
   decode_ug            : morph -> string;
   num_hb_chr           : int;
   num_ug_chr           : int;
   poses                : pos array;
   hb_morphs            : ((morph_type * pos), morph array) Ht.t;
   fsas                 : (pos, fsa_record) Ht.t;
   mutable n            : float;
   entries              : entry array;
   mapping1             : mapping;  (* ug -> hb *)
   mapping2             : mapping;  (* hb -> ug *)
   must1                : (int Hs.t) array;  (* ug -> hb *)
   must2                : (int Hs.t) array;  (* hb -> ug *)
   mapping3             : int list; (* hb insertion characters *)
   edits                : edit list;
   edit_count           : (edit, float) Ht.t; (* only counts edits once per morph-type *)
   true_edit_count      : (edit, float) Ht.t; (* counts ALL edits, even for repeated morph-types *)
   best_count           : (edit, float) Ht.t;
   mutable sub_sum      : float;
   mutable ins_sum      : float;
   mutable del_sum      : float;
   mutable true_sub_sum : float;
   mutable true_ins_sum : float;
   mutable true_del_sum : float;
   pos_count            : (pos, float) Ht.t;
   stm_tbls             : ((morph * pos), (edit list, (int Hs.t) Hs.t) Ht.t) Ht.t;
   pre_tbls             : ((morph * pos), (edit list, (int Hs.t) Hs.t) Ht.t) Ht.t;
   suf_tbls             : ((morph * pos), (edit list, (int Hs.t) Hs.t) Ht.t) Ht.t;
   stm_sum              : ((morph * pos), float) Ht.t;
   pre_sum              : ((morph * pos), float) Ht.t;
   suf_sum              : ((morph * pos), float) Ht.t;
   pre_index1           : ((edit list * pos), int Hs.t) Ht.t;
   stm_index1           : ((edit list * pos), int Hs.t) Ht.t;
   suf_index1           : ((edit list * pos), int Hs.t) Ht.t; 
   pre_index2           : ((morph * pos), int Hs.t) Ht.t;
   stm_index2           : ((morph * pos), int Hs.t) Ht.t;
   suf_index2           : ((morph * pos), int Hs.t) Ht.t; 
   gammas               : (edit, bool) Ht.t;  (* indicator variables for slab (true) vs spike (false) *) 
   mutable alphas_sub_sum   : float;  (* should rename... these are the alphas (dirichlet hyperparameters) for the base distribution(s) *)
   mutable alphas_ins_sum   : float;
   mutable alphas_del_sum   : float;
} 
;;
let fsa_cache = Ht.create 2000;;
let possible_edits_cache = Ht.create 2000;;
type seg_entry = {prob : float; fsa_rec : fsa_record; seg : word; npos : string} 

let init_edit_probs = Ht.create 200;;

let read_ugaritic_data ug_data init_seg_file hb_letters ug_letters pos_list mapping_file =
   let int_of_hb = Ht.of_file char_of_string int_of_string (datadir ^ hb_letters) in
   let hb_of_int = Ht.reverse int_of_hb in
   let int_of_ug = Ht.of_file char_of_string int_of_string (datadir ^ ug_letters) in
   let ug_of_int = Ht.reverse int_of_ug in
   let encode_hb_chr = Ht.find int_of_hb in
   let decode_hb_chr = Ht.find hb_of_int in
   let encode_ug_chr = Ht.find int_of_ug in
   let decode_ug_chr = Ht.find ug_of_int in
   let encode_hb = A.map encode_hb_chr >> aol >> S.explode in
   let decode_hb = S.implode >> loa >> A.map decode_hb_chr in
   let encode_ug = A.map encode_ug_chr >> aol >> S.explode in
   let decode_ug = S.implode >> loa >> A.map decode_ug_chr in
   let num_hb_chr    = Ht.length hb_of_int - 1 in
   let num_ug_chr    = Ht.length ug_of_int - 1 in
   let init_segs =   if !_DEBUG then A.slice ~last:500 (array_of_file (datadir ^ init_seg_file))
                     else array_of_file (datadir ^ init_seg_file) in
   let poses = array_of_file (datadir ^ pos_list) in
   let default_pos = poses.(0) in
   let get_mapping fn =
      assert (Ht.length int_of_ug = num_ug_chr + 1);
      let res = A.make (Ht.length int_of_ug) [] in 
      let proc_ln ln = 
         if ln.[0] <> '#' then
            let ug, heb = S.split ln "\t" in
            let u = (encode_ug_chr >> char_of_string) ug in
            let v = L.map (begin fun str -> 
                  let (str1,str2) = S.split str "." in
                  let h = encode_hb_chr (char_of_string str1) in
                  let prb = fos ("0." ^ str2) in
                  let edit = Sub (u,h) in
                  Ht.add init_edit_probs edit prb;  
                  h 
               end) (S.nsplit (S.strip heb) " ") in
            res.(u) <- v
      in
      A.iter proc_ln (array_of_file fn);
      (* normalize initial edit probs *)
      for u = 1 to num_ug_chr do
         let hb_chrs = A.range 1 (num_hb_chr + 1) in 
         let sum = A.fold_left (fun accum h -> accum +. Ht.get init_edit_probs (Sub (u,h)) 0.) 0. hb_chrs  in
         assert (sum > 0.);
         A.iter (begin fun h -> 
            let ed = Sub (u,h) in
            if Ht.mem init_edit_probs ed then
               let vl = Ht.find init_edit_probs ed in
               Ht.replace init_edit_probs ed (vl /. (sum *. foi (num_ug_chr + 1)))
         end)  hb_chrs;
      done;
      res
   in
   let get_segmentations (w : int array) =
      (* assumptions: stem >= 2, pre <= 2, suf <= 2 *)   
      let num_segs = match A.length w with
         | x when x >= 6 -> 9
         | 5 -> 8
         | 4 -> 6
         | 3 -> 3
         | _ -> 1 in
      let segs = A.make num_segs {pre = [||]; stm = [||]; suf = [||]} in
      let pre = ref [||] in
      let rest = ref w in
      let do_pre = ref true in
      let i = ref 0 in
      while (!do_pre) do
         let stm = ref !rest in
         let suf = ref [||] in
         let do_suf = ref true in
         while (!do_suf) do   
            segs.(!i) <- {pre = !pre; stm = !stm; suf = !suf};
            incr i;
            if A.length !stm > 2 && A.length !suf < 2 then begin
               suf := A.init (A.length !suf + 1) (fun j -> if j = 0 then A.last !stm else !suf.(j-1));
               stm := A.slice ~last:(-1) !stm;
            end else 
               do_suf := false
         done;
         if A.length !rest > 2 && A.length !pre < 2 then begin
            pre := A.init (A.length !pre + 1) (fun j -> if j = A.length !pre then !rest.(0) else !pre.(j));
            rest := A.slice ~first:1 !rest;
         end else 
            do_pre := false
      done;
      assert (!i = num_segs);
      segs
   in
   let proc_ln i ln =
      let proc_word (encode : string -> int array) w : word =
         let morphs = S.nsplita (S.rstrip ~chars:"!" w) "-" in
         match A.length morphs with
            | 3 ->
               if not (morphs.(0).[0] = '#' && morphs.(2).[S.length morphs.(2) - 1] = '#') then begin
                  A.print id morphs;
                  failwith "prefix and suffix should be marked"
               end;
               let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
               {pre = encode res.(0); stm = encode res.(1); suf = encode res.(2)} 
            | 2 ->
               if morphs.(0).[0] = '#' then
                  let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
                  {pre = encode res.(0); stm = encode res.(1); suf = [||]}
               else if morphs.(1).[S.length morphs.(1) - 1] = '#' then
                  let res = A.map (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs in
                  {pre = [||]; stm = encode res.(0); suf = encode res.(1)}
               else begin
                  A.print id morphs;
                  failwith "prefix and suffix should be marked"
               end
            | 1 ->
               let res = (S.strip ~chars:"#" >> S.remove '(' >> S.remove ')') morphs.(0) in
               {pre = [||]; stm = encode res; suf = [||]}
            | _ ->
               A.print id morphs;
               failwith "should have no greater than three morphs"
      in
      let fields = S.nsplit (S.strip ln) "\t" in
      if L.length fields > 1 then begin
         let _, true_word_ug = S.split (L.hd fields) " " in
         let filter_fun w = not (S.ends_with w "!") or not only_plene in
         let true_words_hb = ref (L.map (proc_word encode_hb) (L.filter filter_fun (L.tl fields))) in

         (* add the feminine hebrew form... *)
         if (proc_word encode_ug true_word_ug).suf = [|14|] 
            then if L.exists (fun w -> w.suf = [|21|]) !true_words_hb
               then if not (L.exists (fun w -> w.suf = [|11|]) !true_words_hb) then 
                  begin
                     let w = L.find (fun w -> w.suf = [|21|]) !true_words_hb in
                     let w' = {pre=w.pre; stm=w.stm; suf=[|11|]} in
                     true_words_hb := w' :: !true_words_hb
                  end;
      
         {  true_word_ug      = proc_word encode_ug true_word_ug; 
            true_words_hb     = !true_words_hb; 
            true_pos          = default_pos;
            true_cog          = true;
            segments_ug       = get_segmentations (encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'));
            all_possible      = [||];
            word_hb           = {pre = [||]; stm = [||]; suf = [||]};
            word_ug           = proc_word encode_ug (S.strip init_segs.(i));
            pos               = default_pos;
            cog               = true;
            cog_prob          = -1.0;
            pre_tbl           = Hs.empty ();
            stm_tbl           = Hs.empty ();
            suf_tbl           = Hs.empty ();
            best_ug           = {pre = [||]; stm = [||]; suf = [||]};
            best_hb           = {pre = [||]; stm = [||]; suf = [||]};
            best_pos          = default_pos;
            best_cog          = true;
            best_prob         = -1.0;
            xxx               = false;
            pre_ed   = [];
            stm_ed   = [];
            suf_ed   = []; }
      end else (* not a cognate *)
         let _, true_word_ug = S.split (L.hd fields) " " in
         {  true_word_ug      = {pre = [||]; stm = encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'); suf = [||]};
            true_words_hb     = [];
            true_pos          = default_pos;
            true_cog          = false;
            segments_ug       = get_segmentations (encode_ug (true_word_ug |> S.remove '-' |> S.remove '#'));
            all_possible      = [||];
            word_hb           = {pre = [||]; stm = [||]; suf = [||]};
            word_ug           = proc_word encode_ug (S.strip init_segs.(i));
            pos               = default_pos;
            cog               = true;
            cog_prob          = -1.0;
            pre_tbl           = Hs.empty ();
            stm_tbl           = Hs.empty ();
            suf_tbl           = Hs.empty ();
            best_ug           = {pre = [||]; stm = [||]; suf = [||]};
            best_hb           = {pre = [||]; stm = [||]; suf = [||]};
            best_pos          = default_pos;
            best_cog          = false;
            best_prob         = -1.0;
            xxx               = false;
            pre_ed   = [];
            stm_ed   = [];
            suf_ed   = []; }
   in
   let data          =  if !_DEBUG then A.slice ~last:500 (array_of_file (datadir ^ ug_data)) 
                        else array_of_file (datadir ^ ug_data) in
   assert (A.length data = A.length init_segs);
   
   let entries       =  if !_DEBUG then  A.mapi proc_ln (A.slice ~last:500 (array_of_file (datadir ^ ug_data)))
                        else A.mapi proc_ln (array_of_file (datadir ^ ug_data)) in
   
   let fsas = Ht.init poses (fun pos -> 
      {  pre_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"pre_" ^ pos ^ ".fsa_bin"))));
         stm_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"stm_" ^ pos ^ ".fsa_bin"))));  
         suf_fsa  = Fst.sort_arcs (Fst.minimize (Fst.determinize (Fst.read_from_file (datadir ^"suf_" ^ pos ^ ".fsa_bin")))); }) in
   let hb_morph_keys = [? A : (mtype, pos) | mtype <- A : [|Pre; Stm; Suf|]; pos <- A : poses] in
   let hb_morphs = Ht.init hb_morph_keys 
      (fun (mtype, pos) -> 
         let mtype_str = match mtype with Pre -> "pre" | Stm -> "stm" | Suf -> "suf" in
         array_of_file (datadir ^ mtype_str ^ "_" ^ pos ^ ".list") |> 
         (* get rid of the frequency information (though we might want this later...) *)
         A.map (fun s -> encode_hb (fst (S.split s " ")))) in
                               
   let mapping1      = get_mapping (datadir ^ mapping_file) in
   let mapping2      = A.make (num_hb_chr + 1) [] in
   foreach (1 -- num_ug_chr) (fun u -> L.iter (fun h -> mapping2.(h) <- u :: mapping2.(h)) mapping1.(u)); 
   let mapping3      = [encode_hb_chr 'y'; encode_hb_chr 'w'] in
   L.iter (fun h -> Ht.add init_edit_probs (Ins h) (1. /. foi (L.length mapping3))) mapping3; 
   Ht.add init_edit_probs End (1. /. foi (num_ug_chr + 1)); 

   let edits   = [?L : (Sub (u,h)) | u <- 1 -- num_ug_chr; h <- 1 -- num_hb_chr; L.mem h mapping1.(u)] @
                 (* [L : ? (Del u) | u <- 1 -- num_ug_chr] @ *)
                 [?L : (Ins h) | h <- L : mapping3] @ [End] in

   (* let pre_tbls = Ht.create 500 in
   let stm_tbls = Ht.create 3000 in
   let suf_tbls = Ht.create 500 in
   let pre_index1 = Ht.create 500 in
   let stm_index1 = Ht.create 3000 in
   let suf_index1 = Ht.create 500 in
   let pre_index2 = Ht.create 500 in
   let stm_index2 = Ht.create 3000 in
   let suf_index2 = Ht.create 500 in *)

   (* A.switeri entries (begin fun i e ->
      A.switer poses (begin fun pos ->
         let pre_key = e.word_ug.pre, pos in
         let stm_key = e.word_ug.stm, pos in
         let suf_key = e.word_ug.suf, pos in
         if not (Ht.mem pre_tbls pre_key) then
            Ht.add pre_tbls pre_key (Ht.create 200);
         if not (Ht.mem stm_tbls stm_key) then
            Ht.add stm_tbls stm_key (Ht.create 200);
         if not (Ht.mem suf_tbls suf_key) then
            Ht.add suf_tbls suf_key (Ht.create 200)
      end);
      let pre_key1 = e.word_ug.pre, e.pos in
      let stm_key1 = e.word_ug.stm, e.pos in
      let suf_key1 = e.word_ug.suf, e.pos in
      let pre_key2 = e.pre_ed, e.pos in
      let stm_key2 = e.stm_ed, e.pos in
      let suf_key2 = e.suf_ed, e.pos in
      Ht.incr' (Ht.find pre_count pre_key1) e.pre_ed;
      Ht.incr' (Ht.find stm_count stm_key1) e.stm_ed;
      Ht.incr' (Ht.find suf_count suf_key1) e.suf_ed;
      if not (Ht.mem pre_index1 pre_key2) then 
         Ht.add pre_index1 pre_key2 (Hs.create 1000 (-1));
      if not (Ht.mem stm_index1 stm_key2) then
         Ht.add stm_index1 stm_key2 (Hs.create 1000 (-1));
      if not (Ht.mem suf_index1 suf_key2) then
         Ht.add suf_index1 suf_key2 (Hs.create 1000 (-1));
      Hs.add (Ht.find pre_index1 pre_key2) i;
      Hs.add (Ht.find stm_index1 stm_key2) i;
      Hs.add (Ht.find suf_index1 suf_key2) i;
      if not (Ht.mem pre_index2 pre_key1) then 
         Ht.add pre_index2 pre_key1 (Hs.create 1000 (-1));
      if not (Ht.mem stm_index2 stm_key1) then
         Ht.add stm_index2 stm_key1 (Hs.create 1000 (-1));
      if not (Ht.mem suf_index2 suf_key1) then
         Ht.add suf_index2 suf_key1 (Hs.create 1000 (-1));
      Hs.add (Ht.find pre_index2 pre_key1) i;
      Hs.add (Ht.find stm_index2 stm_key1) i;
      Hs.add (Ht.find suf_index2 suf_key1) i;
   end); *)
   
   {  encode_ug_chr  = encode_ug_chr;
      decode_ug_chr  = decode_ug_chr;
      encode_hb_chr  = encode_hb_chr;
      decode_hb_chr  = decode_hb_chr;  
      encode_ug      = encode_ug;
      decode_ug      = decode_ug;
      encode_hb      = encode_hb;
      decode_hb      = decode_hb;
      entries        = entries;
      n              = foi (A.length entries);
      fsas           = fsas;
      poses          = poses;
      hb_morphs      = hb_morphs;
      mapping1       = mapping1;
      mapping2       = mapping2;
      mapping3       = mapping3;
      num_hb_chr     = num_hb_chr;
      num_ug_chr     = num_ug_chr;
      edit_count     = Ht.create 5000;
      best_count     = Ht.create 5000;
      true_edit_count= Ht.create 5000;
      sub_sum        = 0.;
      ins_sum        = 0.;
      del_sum        = 0.;
      true_sub_sum   = 0.;
      true_ins_sum   = 0.;
      true_del_sum   = 0.;
      pre_tbls       = Ht.create 500;
      stm_tbls       = Ht.create 3000;
      suf_tbls       = Ht.create 500;
      pos_count      = Ht.create 10;
      pre_sum        = Ht.create 500; 
      stm_sum        = Ht.create 500;
      suf_sum        = Ht.create 500;
      pre_index1     = Ht.create 500;
      stm_index1     = Ht.create 3000;
      suf_index1     = Ht.create 500; 
      pre_index2     = Ht.create 500;
      stm_index2     = Ht.create 3000;
      suf_index2     = Ht.create 500;
      edits          = edits;
      gammas         = Ht.create 1000;
      must1          = A.init (num_ug_chr + 1) (fun _ -> Hs.create 20 999);
      must2          = A.init (num_hb_chr + 1) (fun _ -> Hs.create 20 999);
      alphas_sub_sum = 0.;
      alphas_ins_sum = 0.;
      alphas_del_sum = 0.;
   }
;;
let d = read_ugaritic_data "ugaritic.data" "init_morfseg" "hb_letters" "ug_letters" "poses.list" "mapping-updated";;
let get_morph_tables morph mtype pos = 
   let outer_ht = match mtype with Pre -> d.pre_tbls | Stm -> d.stm_tbls | Suf -> d.suf_tbls in
   let key = (morph, pos) in
   if not (Ht.mem outer_ht key) then Ht.add outer_ht key (Ht.create 200); 
   Ht.find outer_ht key
;;   
let rec edit_dist (s1 : string) (s2 : string) =
   (** computes the edit distance (Levenshtein) between two strings *)
  if s1 = "" then S.length s2 else 
    if s2 = "" then S.length s1 else
      let sub_cost = if s1.[0] = s2.[0] then 0 else 1 in
      let sub1, sub2 = S.slice ~first:1 s1, S.slice ~first:1 s2 in
      min (sub_cost + edit_dist sub1 sub2)
		  (min (1 + edit_dist sub1 s2) (1 + edit_dist s1 sub2))
;;
let string_of_edit = function 
   | End -> "End"
   | Ins x -> "Ins " ^ soc (d.decode_hb_chr x)
   | Del x -> "Del " ^ soc (d.decode_ug_chr x)
   | Sub (x,y) -> "Sub " ^ soc (d.decode_ug_chr x) ^ " " ^ soc (d.decode_hb_chr y)
;;
let edit_print out e = S.print out (string_of_edit e);;
let edit_printer paren = edit_print;;
let morph_to_string decode morf = 
   begin try
      let pre = decode morf.pre in
      let stm = decode morf.stm in
      let suf = decode morf.suf in
      if pre <> "" && suf <> "" then
         pre ^ "-" ^ stm ^ "-" ^ suf
      else if pre <> "" && suf = "" then
         pre ^ "-" ^ stm
      else if pre = "" && suf <> "" then
         stm ^ "-" ^ suf
      else stm
   with e -> Array.print (int_printer false) stdout morf.pre; 
             Array.print (int_printer false) stdout morf.stm;
             Array.print (int_printer false) stdout morf.suf;
             raise e
   end
;;
let entry_to_string entry =
   let cog_prob = entry.cog_prob *. foi (A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf) in
   let true_hb_str = if entry.true_cog 
               then S.concat " " (L.map (morph_to_string d.decode_hb) entry.true_words_hb)
               else "XXX" in
   let pos = if entry.cog then entry.pos else "*" in
   let ug_str = morph_to_string d.decode_ug entry.word_ug in
   let hb_str = if entry.xxx then "xxx" else morph_to_string d.decode_hb entry.word_hb in
   ug_str ^ " (" ^ pos ^ ")\t" ^ hb_str ^ "\t" ^ true_hb_str ^ "\t" ^ (sof cog_prob)   
;;
let entry_to_string_best entry =
   let cog_prob = entry.best_prob *. foi (A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf) in
   let true_hb_str = if entry.true_cog 
               then S.concat " " (L.map (morph_to_string d.decode_hb) entry.true_words_hb)
               else "XXX" in
   let pos = if entry.best_cog then entry.best_pos else "*" in
   let ug_str = morph_to_string d.decode_ug entry.best_ug in
   let hb_str = if entry.xxx then "xxx" else morph_to_string d.decode_hb entry.best_hb in
   ug_str ^ " (" ^ pos ^ ")\t" ^ hb_str ^ "\t" ^ true_hb_str ^ "\t" ^ (sof cog_prob)   
;;
let printer_entry k x = k (fun oc -> IO.nwrite oc (entry_to_string x));;
let entry_print out entry = IO.nwrite out (entry_to_string entry);;
let entry_print_best out entry = IO.nwrite out (entry_to_string_best entry);;
let ug_from_edits edit_list = 
   aol $ L.map_filter (function Del u -> Some u | Sub (u,h) -> Some u | _ -> None) edit_list
;;
let hb_from_edits edit_list = 
   aol $ L.map_filter (function Ins h -> Some h | Sub (u,h) -> Some h | _ -> None) edit_list
;;
let get_alpha ed = 
   match ed with
   | Sub _ -> if Ht.find d.gammas ed then gamma_sub_true else gamma_sub_false
   | Ins _ -> if Ht.find d.gammas ed then gamma_ins_true else gamma_ins_false
   | Del _ -> if Ht.find d.gammas ed then gamma_del_true else gamma_del_false
   | End   -> 1.0
;;
let edit_to_int = function
   | End -> 0;
   | Ins hb -> hb;
   | Del ug -> d.num_hb_chr + ug
   | Sub (ug,hb) -> 
      d.num_hb_chr + d.num_ug_chr + ((d.num_hb_chr + 1) * ug + hb)
;;
let int_to_edit = function
   | 0 -> End
   | n when n <= d.num_hb_chr -> Ins n
   | n when n <= d.num_hb_chr + d.num_ug_chr -> Del (n - d.num_hb_chr)
   | n -> 
      let n' = n - d.num_hb_chr - d.num_ug_chr in
      let ug = n' / (d.num_hb_chr + 1) in
      let hb = n' mod (d.num_hb_chr + 1) in
      Sub (ug,hb)
;;
let edit_prob edit =
   (* take note: we may do annealing INSIDE this function *)
   if !init then Ht.find init_edit_probs edit
   else begin
      let alpha = get_alpha edit in
      let edit_count = Ht.count' d.edit_count edit in
      let edit_sum = match edit with Sub _ | End -> d.sub_sum | Ins _ -> d.ins_sum | Del _ -> d.del_sum in
      let alphas_sum = match edit with Sub _ | End -> d.alphas_sub_sum | Ins _ -> d.alphas_ins_sum | Del _ -> d.alphas_del_sum in
      assert (edit_count >= 0.0);
      if !temp_anneal then
         ((alpha +. edit_count) /. (alphas_sum +. edit_sum)) ** schedule.(!r)
      else
         ((alpha +. edit_count) /. (alphas_sum +. edit_sum))
   end
;;
let edit_prob_c n = 
   let edit = int_to_edit n in
   -.log (edit_prob edit)
;; 
let asc_fact par count =
   let fact = ref 0.0 in
   for i = 0 to iof count - 1 do
      fact := !fact +. log (par +. foi i)
   done;
   !fact
;;
let adjust probs = 
   let mx = max_item probs in
   let k = 10. /. mx in
   A.update (fun v -> v *. k) probs
;;
let logs_to_probs a = 
   let min = ref infinity in
   for i = 0 to A.length a - 1 do
      let v = a.(i) in
      if v <> neg_infinity && v < !min then
         min := v
   done;
   assert (!min <> infinity);
   let c = max 0. (-300. -. !min) in
   (* printf p"c = %f, min = %f, a = %{float array}" c !min a; *)
   for i = 0 to A.length a - 1 do
      a.(i) <- exp (a.(i) +. c)
   done
;;

let construct_fsa_only_sub ug_morph =
   (* only allows substitutions (no insertions or deletions) *)
   let fsa, start_state = Fst.new_fst (mtrng) in
   let swap_states = ref [start_state] in
   for i = 0 to A.length ug_morph - 1 do
      let c          = ug_morph.(i) in
      let labels     = d.mapping1.(c) in
      let new_swap_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Sub (c,label)))) labels in
      L.iter2 (begin fun state label ->
         let swap_prob = -.log (edit_prob (Sub (c,label))) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label swap_prob) !swap_states;
      end) new_swap_states labels;
      swap_states := new_swap_states;
   done;
   let end_prob = -. log (edit_prob End) in
   L.iter (fun swap_state -> Fst.set_final fsa swap_state end_prob) !swap_states;
   fsa
;;
let construct_fsa_one_insert ug_morph = 
   (* only alllows one insertion *)
   let fsa, start_state = Fst.new_fst (mtrng) in
   
   let ins_labels = d.mapping3 in
   let ins_states = ref (L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels) in
   L.iter2 (begin fun state label ->
      let ins_prob = -. log (edit_prob (Ins label)) in
      Fst.add_arc fsa start_state state label ins_prob
   end) !ins_states ins_labels;

   let swap_states1 = ref [start_state] in   (* swap states for which no insertion has yet occurred *)
   let swap_states2 = ref [] in              (* swap states for which the insertion has already been used *)
   for i = 0 to A.length ug_morph - 1 do
      let c          = ug_morph.(i) in
      let labels     = d.mapping1.(c) in
      let new_swap_states1 = L.map (fun label -> Fst.add_state fsa (edit_to_int (Sub (c,label)))) labels in
      let new_swap_states2 = L.map (fun label -> Fst.add_state fsa (edit_to_int (Sub (c,label)))) labels in

      (* create edges from previous swap states (with no insertions yet) to new swap states (with no insertions yet *)
      L.iter2 (begin fun state label ->
         let swap_prob = -.log (edit_prob (Sub (c,label))) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label swap_prob) !swap_states1;
      end) new_swap_states1 labels;

      (* create edges from previous swap states (with the insertions used) as well as insertion states,  
         to new swap states (with the insertion used) *)
      L.iter2 (begin fun state label ->
         let swap_prob = -.log (edit_prob (Sub (c,label))) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label swap_prob) !swap_states2;
         L.iter (fun ins_state -> Fst.add_arc fsa ins_state state label swap_prob) !ins_states 
      end) new_swap_states2 labels;
      
      (* create edges from new swap states (with no insertion yet) to new insertion states *)
      let new_ins_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels in
      L.iter2 (begin fun state label ->
         let ins_prob = -.log (edit_prob (Ins label)) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label ins_prob) new_swap_states1
      end) new_ins_states ins_labels;
      
      swap_states1 := new_swap_states1;
      swap_states2 := new_swap_states2;
      ins_states := new_ins_states
   done;
   let ins_end_prob  = -.log (edit_prob End *. ins_prior) in
   let end_prob      = -.log (edit_prob End *. (1. -. ins_prior)) in
   L.iter (fun state -> Fst.set_final fsa state end_prob) !swap_states1;
   L.iter (fun state -> Fst.set_final fsa state ins_end_prob) !swap_states2;
   if A.length ug_morph > 0 then
      L.iter (fun state -> Fst.set_final fsa state ins_end_prob) !ins_states;
   fsa
;;
let construct_fsa ug_morph =
   let fsa, start_state = Fst.new_fst (mtrng) in
   let eps_label = 0 in
   let ins_labels = L.range 1 (d.num_hb_chr + 1) in
   let ins_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels in
   L.iter2 (fun state label -> 
      let ins_prob = -. log (edit_prob (Ins label)) in
      Fst.add_arc fsa start_state state label ins_prob)
      ins_states ins_labels;
   let swap_states = ref [start_state] in
   let spec_states = ref ins_states in
   for i = 0 to A.length ug_morph - 1 do
      let c          = ug_morph.(i) in
      let labels     = d.mapping1.(c) in
      let del_state  = Fst.add_state fsa (edit_to_int (Del c)) in
      let del_prob   = -.log (edit_prob (Del c)) in
      L.iter (fun swap_state -> Fst.add_arc fsa swap_state del_state eps_label del_prob) !swap_states;
      let new_swap_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Sub (c,label)))) labels in
      L.iter2 (fun state label ->
         let swap_prob = -.log (edit_prob (Sub (c,label))) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label swap_prob) !swap_states;
         L.iter (fun spec_state -> Fst.add_arc fsa spec_state state label swap_prob) !spec_states)
         new_swap_states labels;
      let new_ins_states = L.map (fun label -> Fst.add_state fsa (edit_to_int (Ins label))) ins_labels in
      L.iter2 (fun state label ->
         let ins_prob = -. log (edit_prob (Ins label)) in
         L.iter (fun swap_state -> Fst.add_arc fsa swap_state state label ins_prob) new_swap_states)
         new_ins_states ins_labels;
      swap_states := new_swap_states;
      spec_states := del_state :: new_ins_states
   done;
   let end_prob = -. log (edit_prob End) in
   L.iter (fun swap_state -> Fst.set_final fsa swap_state end_prob) !swap_states;
   L.iter (fun spec_state -> Fst.set_final fsa spec_state end_prob) !spec_states;
   fsa
;;
let get_fsa ug_morph pos mtype =
   try
      let fsa = Ht.find fsa_cache (ug_morph,pos,mtype) in
      Fst.reweight_fsa fsa;
      fsa
   with Not_found -> 
      let fsa_ = construct_fsa_one_insert ug_morph in
      let fsa = match mtype with
         | Pre -> Fst.intersect fsa_ (Ht.find d.fsas pos).pre_fsa
         | Stm -> Fst.intersect fsa_ (Ht.find d.fsas pos).stm_fsa
         | Suf -> Fst.intersect fsa_ (Ht.find d.fsas pos).suf_fsa in
      Ht.add fsa_cache (ug_morph,pos,mtype) fsa; 
      fsa
;;

let gammas_prior () = 
   (* returns log-prob ignoring the normalization constant *)
   let res = ref 0. in
   let del_count = ref 0 in
   let ins_count = ref 0 in
   let subug_counts = A.make d.num_ug_chr 0 in
   let subhb_counts = A.make d.num_hb_chr 0 in
   for u = 1 to d.num_ug_chr do
      L.iter (fun h ->
         if Ht.find d.gammas (Sub (u,h)) then begin
            subug_counts.(u-1) <- subug_counts.(u-1) + 1;
            subhb_counts.(h-1) <- subhb_counts.(h-1) + 1
         end) d.mapping1.(u)
   done;      
   (* for u = 1 to d.num_ug_chr do   (* for deletions *)
      if Ht.get d.gammas (Del u) false then del_count := !del_count + 1
   done;
   for h = 1 to d.num_hb_chr do  (* for insertions *)
      if Ht.get d.gammas (Ins h) false then ins_count := !ins_count + 1
   done; *)
   let h_fertility = A.init (max 4 (max_item subhb_counts + 1)) (fun n -> A.count (eq n) subhb_counts) in
   let u_fertility = A.init (max 4 (max_item subug_counts + 1)) (fun n -> A.count (eq n) subug_counts) in
   
   (* drintf p"";
   drintf p"insert count : %d" !ins_count;
   drintf p"delete count : %d" !del_count; *)
   (* printf p"hb counts : %{int array}" subhb_counts;
   printf p"ug sub fertilities : %{int array}" u_fertility;
   printf p"hb sub fertilities : %{int array}" h_fertility; *)

   if h_fertility.(0) > 0 || u_fertility.(0) > 0 then
      res := neg_infinity;
   if h_fertility.(3) > 1 || u_fertility.(3) > 0 || A.length h_fertility > 4 || A.length u_fertility > 4 then
      res := neg_infinity;
   
   let h_overbudget = foi (max 0 (h_fertility.(2) - hb_budget)) in
   let u_overbudget = foi (max 0 (u_fertility.(2) - ug_budget)) in
   res := !res +. penalty *. (h_overbudget +. u_overbudget);
    
   (* res := !res +. (if !del_count < A.length del_lp then del_lp.(!del_count) else neg_infinity);
   res := !res +. (if !ins_count < A.length ins_lp then ins_lp.(!ins_count) else neg_infinity);
   foreach (A.enum subug_counts) (fun c -> 
      res := !res +. (if c < A.length subug_lp then subug_lp.(c) else neg_infinity));
   foreach (A.enum subhb_counts) (fun c ->
      res := !res +. (if c < A.length subhb_lp then subhb_lp.(c) else neg_infinity)); *)
   !res
;;
let gammas_ll () =
   let res = ref 0. in
   for u = 1 to d.num_ug_chr do
      L.iter (begin fun h ->
         let sub = Sub (u,h) in
         let count = Ht.count' d.edit_count sub in
         let alpha = get_alpha sub in
         (* if h == 21 then
            printf p"%{edit} = %f    %f (%{bool}) / %f" sub count alpha (Ht.find d.gammas sub) d.alphas_sub_sum;  *)
         res := !res +. asc_fact alpha count
      end) d.mapping1.(u)
   done;
   let alphas_sub_sum = ref 1. in (* for End *)
   let sub_sum = ref (Ht.count' d.edit_count End) in
   for u = 1 to d.num_ug_chr do
      L.iter (fun h -> 
         let sub = Sub (u,h) in
         let count = Ht.count' d.edit_count sub in
         sub_sum := !sub_sum +. count;
         alphas_sub_sum := !alphas_sub_sum +. (if Ht.find d.gammas sub then gamma_sub_true else gamma_sub_false)
      ) d.mapping1.(u)
   done;
   (* printf p"1: mine = %d, theirs = %d" (iof !alphas_sub_sum) (iof d.alphas_sub_sum);
   assert (!alphas_sub_sum = d.alphas_sub_sum);
   printf p"2: mine = %d, theirs = %d" (iof !sub_sum) (iof d.sub_sum);
   assert (!sub_sum = d.sub_sum); *)
   !res -. asc_fact d.alphas_sub_sum d.sub_sum
;;
let check_edit_counts i = 
   let alphas_sub_sum = ref 1. in (* for End *)
   let sub_sum = ref (Ht.count' d.edit_count End) in
   for u = 1 to d.num_ug_chr do
      for h = 1 to d.num_hb_chr do
         let sub = Sub (u,h) in
         let count = Ht.count' d.edit_count sub in
         sub_sum := !sub_sum +. count;
         if L.mem h d.mapping1.(u) then 
            alphas_sub_sum := !alphas_sub_sum +. (if Ht.find d.gammas sub then gamma_sub_true else gamma_sub_false)
      done
   done;
   (* printf p"1: mine = %d, theirs = %d (%d)" (iof !alphas_sub_sum) (iof d.alphas_sub_sum) i; *)
   assert (!alphas_sub_sum = d.alphas_sub_sum);
   (* printf p"2: mine = %d, theirs = %d (%d)" (iof !sub_sum) (iof d.sub_sum) i; *)
   assert (!sub_sum = d.sub_sum);
;;   
  
let add_sub ed = 
   match ed with
   | Sub _ -> 
      if not (Ht.get d.gammas ed false) then begin
         d.alphas_sub_sum <- d.alphas_sub_sum -. gamma_sub_false +. gamma_sub_true;
         Ht.replace d.gammas ed true;
      end
   | _ -> assert false;
;;
let rem_sub ed =
   match ed with
   | Sub _ -> 
         if (Ht.find d.gammas ed) then begin
            d.alphas_sub_sum <- d.alphas_sub_sum -. gamma_sub_true +. gamma_sub_false;
            Ht.replace d.gammas ed false
         end
   | _ -> assert false;
;;
let sample_gammas_ug u =
   let poss = aol d.mapping1.(u) in
   let must = Hs.to_array d.must1.(u) in
   let remain = A.filter (fun h -> not (A.mem h must)) poss in
   A.iter (fun h -> rem_sub (Sub (u,h))) remain; 

   match (2 - A.length must) with
   | 2 ->   (* distribute 1 - 2 "true"s over remain  *)
      let k = A.length remain in
      let a = A.make (choose k 2 + k) [] in
      let probs = A.make (choose k 2 + k) 0. in
      let idx = ref 0 in
      for i = 0 to A.length remain - 1 do
         let h = remain.(i) in
         a.(!idx) <- [h];
         let sub = Sub (u,h) in
         add_sub sub;
         (* printf p"%{edit} : %{bool}" sub (Ht.find d.gammas sub); *)
         let ll = gammas_ll () in
         let lp = gammas_prior () in
         (* printf p"ll = %f    lp = %f" ll lp; *)
         probs.(!idx) <- (ll +. lp);
         incr idx;
         for j = i + 1 to A.length remain - 1 do
            let h' = remain.(j) in
            a.(!idx) <- [h;h'];
            let sub = Sub (u,h') in
            add_sub sub;
            (* printf p"%{edit} : %{bool}" sub (Ht.find d.gammas sub); *)
            let ll = gammas_ll () in
            let lp = gammas_prior () in
            (* printf p"ll = %f    lp = %f" ll lp; *)
            probs.(!idx) <- (ll +. lp);
            rem_sub (Sub (u,h'));
            incr idx
         done;
         rem_sub (Sub (u,h))
      done;
      assert (!idx = A.length a);
      logs_to_probs probs;
      (* printf p"ug %d : a = %{int list array}   probs = %{float array}" u a probs; *)
      let resi = sample probs in
      L.iter (fun h -> add_sub (Sub (u,h))) a.(resi);
   | 1 ->   (* distribute up to 1 "true" over remain *)
      let k = A.length remain in
      let probs = A.init (k+1) (fun i ->
         if i = 0 then (gammas_ll () +. gammas_prior ())
         else begin
            let sub = Sub (u, remain.(i-1)) in
            add_sub sub;
            let v = (gammas_ll () +. gammas_prior ()) in
            rem_sub sub; v
         end) in
      (* printf p"ug %d : a2, probs = %{float array}" u probs; *)
      logs_to_probs probs;
      let i = sample probs in
      if i <> 0 then 
         let h = remain.(i-1) in add_sub (Sub (u,h))
   | _ -> ()
;;
let sample_gammas_hb h =
   let poss = aol d.mapping2.(h) in
   let must = Hs.to_array d.must2.(h) in
   let remain = A.filter (fun u -> not (A.mem u must)) poss in
   A.iter (fun u -> rem_sub (Sub (u,h))) remain; 

   match (2 - A.length must) with
   | 2 ->   (* distribute 1 - 2 "true"s over remain  *)
      let k = A.length remain in
      let a = A.make (choose k 2 + k) [] in
      let probs = A.make (choose k 2 + k) 0. in
      let idx = ref 0 in
      for i = 0 to A.length remain - 1 do
         let u = remain.(i) in
         a.(!idx) <- [u];
         add_sub (Sub (u,h));
         let ll = gammas_ll () in
         let lp = gammas_prior () in
         (* printf p"ll = %f    lp = %f" ll lp; *)
         probs.(!idx) <- (ll +. lp);
         incr idx;
         for j = i + 1 to A.length remain - 1 do
            let u' = remain.(j) in
            a.(!idx) <- [u;u'];
            add_sub (Sub (u',h));
            let ll = gammas_ll () in
            let lp = gammas_prior () in
            (* printf p"ll = %f    lp = %f" ll lp; *)
            probs.(!idx) <- (ll +. lp);
            rem_sub (Sub (u',h));
            incr idx
         done;
         rem_sub (Sub (u,h))
      done;
      assert (!idx = A.length a);
      (* printf p"hb %d : a = %{int list array}   probs = %{float array}" h a probs; *)
      logs_to_probs probs;
      let resi = sample probs in
      L.iter (fun u -> add_sub (Sub (u,h))) a.(resi);
   | 1 ->   (* distribute up to 1 "true" over remain *)
      let k = A.length remain in
      let probs = A.init (k+1) (fun i ->
         if i = 0 then begin
            let ll = gammas_ll () in
            let lp = gammas_prior () in
            (* printf p"ll = %f    lp = %f" ll lp; *)
            ll +. lp
         end else begin
            let sub = Sub (remain.(i-1),h) in
            add_sub sub;
            let ll = gammas_ll () in
            let lp = gammas_prior () in
            (* printf p"ll = %f    lp = %f" ll lp; *)
            rem_sub sub; ll +. lp
         end) in
      (* printf p"hb %d : a2, probs = %{float array}" h probs; *)
      logs_to_probs probs;
      let i = sample probs in
      if i <> 0 then 
         let u = remain.(i-1) in add_sub (Sub (u,h))
   | _ -> ()
;;
let init_gammas () =
   foreach (L.enum d.edits) (function 
      | Sub (u,h) -> Ht.replace d.gammas (Sub (u,h)) false 
      | End       -> Ht.replace d.gammas End false 
      | Del u     -> Ht.replace d.gammas (Del u) false
      | Ins h     -> Ht.replace d.gammas (Ins h) (L.mem h d.mapping3));

   for u = 1 to d.num_ug_chr do
      let hbs = aol d.mapping1.(u) in
      if A.length hbs = 1 then
         ()
         (* Ht.replace d.gammas (Sub (u,hbs.(0))) true *)
      else begin
         let counts = A.map (fun h -> Ht.count' d.edit_count (Sub (u,h))) hbs in
         let i,mx = max_itemi counts in
         let mx2 = max_item (A.filteri (fun j _ -> j <> i) counts) in
         let ratio = mx /. mx2 in
         if ratio > 5.0 then begin
            let super_h = hbs.(i) in
            d.mapping1.(u) <- [super_h];
            (* foreach (A.enum hbs) (fun h -> Ht.replace d.gammas (Sub (u,h)) false);
            Ht.replace d.gammas (Sub (u,super_h)) true; *)
         end
      end
   done;
   Ht.clear fsa_cache;
   (* rebuild mapping2 *)
   foreach (1 -- d.num_hb_chr) (fun h -> d.mapping2.(h) <- []);
   foreach (1 -- d.num_ug_chr) (fun u -> L.iter (fun h -> d.mapping2.(h) <- u :: d.mapping2.(h)) d.mapping1.(u));
   
   foreach (1 -- d.num_ug_chr) (fun u -> 
      match d.mapping1.(u) with [h] -> 
         begin
            Hs.add d.must1.(u) h;
            Hs.add d.must2.(h) u;
         end
      | _ -> ());
      
   foreach (1 -- d.num_hb_chr) (fun h -> 
      match d.mapping2.(h) with [u] -> 
         begin
            Hs.add d.must1.(u) h;
            Hs.add d.must2.(h) u;
         end
      | _ -> ());
;;
let init_gammas2 () =
   let counts_u = Ht.create 50 in
   let counts_h = Ht.create 50 in
   foreach (1 -- d.num_ug_chr) (fun u -> 
      let (counts : float array) = A.init (d.num_hb_chr + 1) (fun h -> if h = 0 then 0. else Ht.count' d.edit_count (Sub (u,h))) in
      Ht.add counts_u u counts);
   foreach (1 -- d.num_hb_chr) (fun h ->
      let (counts : float array) = A.init (d.num_ug_chr + 1) (fun u -> if u = 0 then 0. else Ht.count' d.edit_count (Sub (u,h))) in
      Ht.add counts_h h counts);
   
   let three_allowed = ref 0 in
   foreach (1 -- d.num_hb_chr) (fun h ->
      let rest = L.filter (fun u -> not (Hs.mem d.must2.(h) u)) d.mapping2.(h) in
      let percents = L.map (fun u -> let counts = Ht.find counts_u u in counts.(h) /. (A.sum counts)) rest in
      let combined = aol (L.combine percents rest) in
      A.sort (fun x y -> - compare (fst x) (fst y)) combined; 
      (* printf p"%d counts = %{(float * int) array}" h combined; *)
      let allowed = if !three_allowed > 0 then 3 else 2 in
      let sofar = ref 0 in
      let must = Hs.to_list d.must2.(h) in
      foreach (L.enum must) (fun u ->
         let edit = Sub (u,h) in
         (* printf p"must: %{edit}" edit; *)
         Ht.replace d.gammas edit true;
         incr sofar);
      let index = ref 0 in
      while (!sofar < allowed && !index < A.length combined) do
         let (pct,u) = combined.(!index) in
         incr index;
         if pct > 0.09 then begin
            let edit = Sub (u,h) in
            (* printf p"> 0.09: %{edit}" edit; *)
            Ht.replace d.gammas edit true;
            incr sofar;
         end
      done;
      assert (if !three_allowed > 0 then !sofar <= 3 else (!sofar <= 2 || (!sofar = 3 && h = 7))); 
      if !sofar = 2 then decr three_allowed);

   foreach (1 -- d.num_ug_chr) (fun u ->
      let hbs = L.filter (fun h -> Ht.find d.gammas (Sub (u,h))) d.mapping1.(u) in
      let counts = L.map (fun h -> Ht.count' d.edit_count (Sub (u,h))) hbs in
      let combined = aol (L.combine counts hbs) in
      A.sort (fun x y -> - compare (fst x) (fst y)) combined;
      assert (!_DEBUG || A.length combined > 0);
      if A.length combined = 0 then
         Ht.replace d.gammas (Sub (u, L.hd d.mapping1.(u))) true;
      A.iter (fun (_,h) -> Ht.replace d.gammas (Sub (u,h)) false) (A.slice ~first:2 combined));
   
   let alpha_sum = ref 1. in (* for End *)
   let sub_sum = ref (Ht.count' d.edit_count End) in
   for u = 1 to d.num_ug_chr do
      L.iter (fun h -> 
         alpha_sum := !alpha_sum +. (if Ht.find d.gammas (Sub (u,h)) then gamma_sub_true else gamma_sub_false);
         sub_sum := !sub_sum +. (Ht.count' d.edit_count (Sub (u,h)))) 
      d.mapping1.(u)
   done;
   d.alphas_sub_sum <- !alpha_sum;
   d.alphas_ins_sum <- L.fold_left 
      (fun acc h -> acc +. (if Ht.get d.gammas (Ins h) false then gamma_ins_true else gamma_ins_false)) 0. d.mapping3;
;;
let init_gammas_debug () =
   foreach (L.enum d.edits) (function 
      | Sub (u,h) -> Ht.replace d.gammas (Sub (u,h)) false 
      | End       -> Ht.replace d.gammas End false 
      | Del u     -> Ht.replace d.gammas (Del u) false
      | Ins h     -> Ht.replace d.gammas (Ins h) (L.mem h d.mapping3));

   for u = 1 to d.num_ug_chr do
      match u with
      | 4 -> d.mapping1.(u) <- [3]
      | 6 -> d.mapping1.(u) <- [4]
      | 15 -> d.mapping1.(u) <- [7]
      | 16 -> d.mapping1.(u) <- [12]
      | 18 -> d.mapping1.(u) <- [14]
      | 19 -> d.mapping1.(u) <- [15]
      | 21 -> d.mapping1.(u) <- [17]
      | 22 -> d.mapping1.(u) <- [18]
      | 28 -> d.mapping1.(u) <- [4]
      | _ -> ()
   done;
   Ht.clear fsa_cache;
   (* rebuild mapping2 *)
   foreach (1 -- d.num_hb_chr) (fun h -> d.mapping2.(h) <- []);
   foreach (1 -- d.num_ug_chr) (fun u -> L.iter (fun h -> d.mapping2.(h) <- u :: d.mapping2.(h)) d.mapping1.(u));
   
   foreach (1 -- d.num_ug_chr) (fun u -> 
      match d.mapping1.(u) with [h] -> 
         begin
            Hs.add d.must1.(u) h;
            Hs.add d.must2.(h) u;
         end
      | _ -> ());
      
   foreach (1 -- d.num_hb_chr) (fun h -> 
      match d.mapping2.(h) with [u] -> 
         begin
            Hs.add d.must1.(u) h;
            Hs.add d.must2.(h) u;
         end
      | _ -> ());

   let l = [(1,1);(1,2);(2,16);(2,19);(3,10);(4,3);(5,3);(6,4);(7,5);(8,6);(9,5);(9,23);(10,7);(11,8);(12,9);
            (13,10);(14,11);(14,21);(15,7);(16,12);(17,13);(18,14);(19,15);(20,16);(21,17);(22,18);(23,19);
            (23,22);(24,11);(24,20);(25,7);(26,1);(27,21);(28,4);(29,22);(30,8);(30,23)] in
   
   for u = 1 to d.num_ug_chr do
      L.iter (fun h -> if L.mem (u,h) l then Ht.replace d.gammas (Sub (u,h)) true else Ht.replace d.gammas (Sub (u,h)) false) d.mapping1.(u)
   done;

   let alpha_sum = ref 1. in (* for End *)
   let sub_sum = ref (Ht.count' d.edit_count End) in
   for u = 1 to d.num_ug_chr do
      L.iter (fun h -> 
         alpha_sum := !alpha_sum +. (if Ht.find d.gammas (Sub (u,h)) then gamma_sub_true else gamma_sub_false);
         sub_sum := !sub_sum +. (Ht.count' d.edit_count (Sub (u,h)))) 
      d.mapping1.(u)
   done;
   d.alphas_sub_sum <- !alpha_sum;
   d.alphas_ins_sum <- L.fold_left 
      (fun acc h -> acc +. (if Ht.get d.gammas (Ins h) false then gamma_ins_true else gamma_ins_false)) 0. d.mapping3;
;;
let sample_gammas () = 
   let hs = A.init d.num_hb_chr (fun i -> ("hb", i+1)) in
   let us = A.init d.num_ug_chr (fun i -> ("ug", i+1)) in
   let both = A.append hs us in
   A.shuffle both;
   A.iter (fun (s,c) -> match s with "hb" -> sample_gammas_hb c | "ug" -> sample_gammas_ug c | _ -> assert false) both
;;

let decrement_entry_counts entry i =
   d.n <- d.n -. 1.;
   let opos = entry.pos in
   let opre = entry.word_ug.pre in
   let ostm = entry.word_ug.stm in
   let osuf = entry.word_ug.suf in
      
   let pre_tbls = get_morph_tables opre Pre opos in
   let stm_tbls = get_morph_tables ostm Stm opos in
   let suf_tbls = get_morph_tables osuf Suf opos in

   let decr_ed ed =
      Ht.decr' d.edit_count ed;
      match ed with
         | Sub _ | End -> d.sub_sum <- d.sub_sum -. 1.
         | Ins _ -> d.ins_sum <- d.ins_sum -. 1.
         | Del _ -> d.del_sum <- d.del_sum -. 1.
   in
   let decr_true_ed ed =
      Ht.decr' d.true_edit_count ed;
      match ed with
         | Sub _ | End -> d.true_sub_sum <- d.true_sub_sum -. 1.
         | Ins _ -> d.true_ins_sum <- d.true_ins_sum -. 1.
         | Del _ -> d.true_del_sum <- d.true_del_sum -. 1.
   in
   
   Hs.remove entry.pre_tbl i;
   Hs.remove entry.stm_tbl i;
   Hs.remove entry.suf_tbl i;

   if Hs.length entry.pre_tbl = 0 then (
      L.iter decr_ed entry.pre_ed;
      Hs.remove (Ht.find pre_tbls entry.pre_ed) entry.pre_tbl);
   
   if Hs.length entry.stm_tbl = 0 then (
      L.iter decr_ed entry.stm_ed;
      Hs.remove (Ht.find stm_tbls entry.stm_ed) entry.stm_tbl);
   
   if Hs.length entry.suf_tbl = 0 then (
      L.iter decr_ed entry.suf_ed;
      Hs.remove (Ht.find suf_tbls entry.suf_ed) entry.suf_tbl);
      
   L.iter decr_true_ed entry.pre_ed;
   L.iter decr_true_ed entry.stm_ed;
   L.iter decr_true_ed entry.suf_ed;

   Ht.decr' d.pre_sum (opre,opos);
   Ht.decr' d.stm_sum (ostm,opos);
   Ht.decr' d.suf_sum (osuf,opos);
   Ht.decr' d.pos_count opos;

   let pre_index1 = Ht.find d.pre_index1 (entry.pre_ed,opos) in
   let stm_index1 = Ht.find d.stm_index1 (entry.stm_ed,opos) in
   let suf_index1 = Ht.find d.suf_index1 (entry.suf_ed,opos) in
   
   let pre_index2 = Ht.find d.pre_index2 (opre,opos) in
   let stm_index2 = Ht.find d.stm_index2 (ostm,opos) in
   let suf_index2 = Ht.find d.suf_index2 (osuf,opos) in
   Hs.remove pre_index1 i;
   Hs.remove stm_index1 i;
   Hs.remove suf_index1 i;
   Hs.remove pre_index2 i;
   Hs.remove stm_index2 i;
   Hs.remove suf_index2 i;
   
   (* let n1 = foi (Hs.length pre_index1) in
   let n2 = foi (Hs.length stm_index1) in
   let n3 = foi (Hs.length suf_index1) in
   printf p"(%d : %{edit list}) n1 = %d,  count = %d" i entry.pre_ed (iof n1) (iof $ Ht.count' pre_count entry.pre_ed);
   printf p"(%d : %{edit list}) n2 = %d,  count = %d" i entry.stm_ed (iof n2) (iof $ Ht.count' stm_count entry.stm_ed);
   printf p"(%d : %{edit list}) n3 = %d,  count = %d" i entry.suf_ed (iof n3) (iof $ Ht.count' suf_count entry.suf_ed);
   if not !init then begin
      assert (n1 = Ht.count' pre_count entry.pre_ed);
      assert (n2 = Ht.count' stm_count entry.stm_ed);
      assert (n3 = Ht.count' suf_count entry.suf_ed);   
   end; *)
   if Hs.length pre_index1 = 0 then
      Ht.remove d.pre_index1 (entry.pre_ed,opos);
   if Hs.length stm_index1 = 0 then
      Ht.remove d.stm_index1 (entry.stm_ed,opos);
   if Hs.length suf_index1 = 0 then
      Ht.remove d.suf_index1 (entry.suf_ed,opos);
      
   if Hs.length pre_index2 = 0 then
      Ht.remove d.pre_index2 (opre,opos);
   if Hs.length stm_index2 = 0 then
      Ht.remove d.stm_index2 (ostm,opos);
   if Hs.length suf_index2 = 0 then
      Ht.remove d.suf_index2 (osuf,opos);
   
   
   (* assert (Ht.find pre_count entry.pre_ed >= 0.);
   assert (Ht.find stm_count entry.stm_ed >= 0.);
   assert (Ht.find suf_count entry.suf_ed >= 0.); *)
   assert (Ht.find d.pre_sum (opre,opos) >= 0.);
   assert (Ht.find d.stm_sum (ostm,opos) >= 0.);
   assert (Ht.find d.suf_sum (osuf,opos) >= 0.);
   assert (Ht.find d.pos_count opos >= 0.);
;;
let increment_pos_counts entry =
   (* increment counts *)
   d.n <- d.n +. 1.;
   let npos = entry.pos in
   let nseg = entry.word_ug in
   Ht.incr' d.pos_count npos;
   Ht.incr' d.pre_sum (nseg.pre,npos);
   Ht.incr' d.stm_sum (nseg.stm,npos);
   Ht.incr' d.suf_sum (nseg.suf,npos);
   if not (Ht.mem d.pre_tbls (nseg.pre,npos)) then Ht.add d.pre_tbls (nseg.pre,npos) (Ht.create 200);
   if not (Ht.mem d.stm_tbls (nseg.stm,npos)) then Ht.add d.stm_tbls (nseg.stm,npos) (Ht.create 200);
   if not (Ht.mem d.suf_tbls (nseg.suf,npos)) then Ht.add d.suf_tbls (nseg.suf,npos) (Ht.create 200);
;;
let increment_mrf_counts entry mtype i =
   let pos     = entry.pos in
   let nmorf   = match mtype with Pre -> entry.word_ug.pre  | Stm -> entry.word_ug.stm    | Suf -> entry.word_ug.suf in
   let nedits  = match mtype with Pre -> entry.pre_ed       | Stm -> entry.stm_ed         | Suf -> entry.suf_ed in
   let tbl     = match mtype with Pre -> entry.pre_tbl      | Stm -> entry.stm_tbl        | Suf -> entry.suf_tbl in
   let index1  = match mtype with Pre -> d.pre_index1       | Stm -> d.stm_index1         | Suf -> d.suf_index1 in
   let index2  = match mtype with Pre -> d.pre_index2       | Stm -> d.stm_index2         | Suf -> d.suf_index2 in
   let tbls_   = match mtype with Pre -> d.pre_tbls         | Stm -> d.stm_tbls           | Suf -> d.suf_tbls in
   let tbls    = Ht.find tbls_ (nmorf,pos) in 
   
   if not (Ht.mem index1 (nedits,pos)) then
      Ht.add index1 (nedits,pos) (Hs.create 500 (-1));
   let indices1 = Ht.find index1 (nedits,pos) in
   Hs.add indices1 i;

   if not (Ht.mem index2 (nmorf,pos)) then
      Ht.add index2 (nmorf,pos) (Hs.create 500 (-1));
   let indices2 = Ht.find index2 (nmorf,pos) in
   Hs.add indices2 i;
   
   let incr_ed ed =
      Ht.incr' d.edit_count ed;
      match ed with
         | Sub _ | End -> d.sub_sum <- d.sub_sum +. 1.
         | Ins _ -> d.ins_sum <- d.ins_sum +. 1.
         | Del _ -> d.del_sum <- d.del_sum +. 1.
   in
   let incr_true_ed ed =
      Ht.incr' d.true_edit_count ed;
      match ed with
         | Sub _ | End -> d.true_sub_sum <- d.true_sub_sum +. 1.
         | Ins _ -> d.true_ins_sum <- d.true_ins_sum +. 1.
         | Del _ -> d.true_del_sum <- d.true_del_sum +. 1.
   in
   
   Hs.add tbl i;
   if Hs.length tbl = 1 then (
      L.iter incr_ed nedits;
      if not (Ht.mem tbls nedits) then
         Ht.add tbls nedits (Hs.create 50 (Hs.empty ()));
      Hs.add (Ht.find tbls nedits) tbl);
   
   L.iter incr_true_ed nedits;

   (* let n = foi (Hs.length indices1) in
   printf p"(%d) n = %d,  count = %d" i (iof n) (iof $ Ht.count' mrf_counts nedits);
   assert (n = Ht.count' mrf_counts nedits); *)
;;

let morph_prob ?(base=false) ug_mrf edits pos mtype = 
   let tbls    = Ht.get (get_morph_tables ug_mrf mtype pos) edits (Hs.empty ()) in
   let count   = foi (Hs.fold (fun hs accum -> accum + Hs.length hs) tbls 0) in  
   let pos_n   = Ht.count' d.pos_count pos in
   let alpha   = match mtype with Pre -> alpha_pre | Stm -> alpha_stm | Suf -> alpha_suf in
   let n = if mtype = Stm then d.n else pos_n in
   let edits_prob = L.fold_left (fun accum edit -> edit_prob edit *. accum) 1. edits in
   if base or !init then 
      edits_prob
   else 
      (alpha *. edits_prob /. (n +. alpha))  +.  (count /. (n +. alpha))
;;
let get_possible_edits ug_mrf pos mtype =
   try 
      Ht.find possible_edits_cache (ug_mrf,pos,mtype)
   with Not_found ->
      let fsa = get_fsa ug_mrf pos mtype in
      let edit_lists = A.map (fun edits -> L.map int_to_edit (loa edits)) (Fst.get_all_edits fsa) in
      Ht.add possible_edits_cache (ug_mrf,pos,mtype) edit_lists;
      edit_lists
;;
let all_possible_predictions i entry =
   if i mod 100 = 0 then
      printf p"getting all possible:  %d" i;

   let res = ref [] in
   let num_segs = A.length entry.segments_ug in
   let num_pos = A.length d.poses in
   for j = 0 to num_segs * num_pos - 1 do
      let pos = d.poses.(j mod num_pos) in
      let seg = entry.segments_ug.(j / num_pos) in
      let pre_fsa = get_fsa seg.pre pos Pre in
      let stm_fsa = get_fsa seg.stm pos Stm in
      let suf_fsa = get_fsa seg.suf pos Suf in
      if L.for_all (fun fsa -> Obj.magic (Fst.get_start fsa) <> -1) [pre_fsa; stm_fsa; suf_fsa] then
         let pres = Fst.get_all_edits pre_fsa in
         let stms = Fst.get_all_edits stm_fsa in
         let sufs = Fst.get_all_edits suf_fsa in
         assert (A.length pres > 0);
         assert (A.length stms > 0);
         assert (A.length sufs > 0);
         for i = 0 to A.length pres - 1 do
            for j = 0 to A.length stms - 1 do
               for k = 0 to A.length sufs - 1 do
                  let pre = L.map int_to_edit (loa pres.(i)) in
                  let stm = L.map int_to_edit (loa stms.(j)) in
                  let suf = L.map int_to_edit (loa sufs.(k)) in
                  res := { p_ug = seg; 
                           p_hb = {pre = hb_from_edits pre; stm = hb_from_edits stm; suf = hb_from_edits suf};
                           p_pre_ed = pre;
                           p_stm_ed = stm;
                           p_suf_ed = suf;
                           p_pos = pos } :: !res
               done
            done
         done
   done;
   entry.all_possible <- aol !res;
;;

let sample_cog entry i =
   if not !init then begin
      if entry.cog then
         decr cogs;
      entry.cog <- false;
      let cog_prob = entry.cog_prob in
      let len = A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf + 1 in
      let noncog_prob = exp (10. +. foi len *. (log 1. -. log 31.)) in
      let a = [|cog_prob *. cog_prior; noncog_prob *. (1. -. cog_prior)|] in
      if anneal then begin
         adjust a; 
         A.update (fun v -> v ** schedule.(!r)) a;
      end;
      (* print_int i; print_string " ";
      A.print sof a; *)
      let rn = Fst.random mtrng (a.(0) +. a.(1)) in
      if rn < a.(0) then begin
         incr cogs;
         entry.cog <- true
      end
   end
;;
let sample_prediction entry i =
   if entry.cog then decrement_entry_counts entry i;

   if A.length entry.all_possible = 0 then begin
      printf p"no possible: %d" i;
      entry.xxx <- true;
      entry.cog <- false;
      entry.best_cog <- false;
      decr cogs
   end
   else begin
      
      let probs = A.map (begin fun p -> 
            let pre = p.p_ug.pre in
            let stm = p.p_ug.stm in
            let suf = p.p_ug.suf in
            let pre_ed = p.p_pre_ed in
            let stm_ed = p.p_stm_ed in
            let suf_ed = p.p_suf_ed in
            let pos = p.p_pos in
            morph_prob ~base:false pre pre_ed pos Pre *.
            morph_prob ~base:false stm stm_ed pos Stm *.
            morph_prob ~base:false suf suf_ed pos Suf 
         end) entry.all_possible in
      
      let prob_sum = A.sum probs in
      entry.cog_prob    <- prob_sum;          (* may want to switch this to the max prob (viterbi)*)
      sample_cog entry i;
      if entry.cog then begin
         if anneal then (adjust probs; A.update (fun v -> v ** schedule.(!r)) probs);
         let resi = sample ~sum:(if anneal then None else Some prob_sum) probs in
         let predict = entry.all_possible.(resi) in
         entry.word_ug     <- predict.p_ug;
         entry.word_hb     <- predict.p_hb;
         entry.pos         <- predict.p_pos;
         entry.pre_ed      <- predict.p_pre_ed;
         entry.stm_ed      <- predict.p_stm_ed;
         entry.suf_ed      <- predict.p_suf_ed;
         
         increment_pos_counts entry;
         increment_mrf_counts entry Pre i;
         increment_mrf_counts entry Stm i;
         increment_mrf_counts entry Suf i;
      end
   end;
   check_edit_counts i
;;
let best_prediction entry i = 
   if entry.cog && not !init then decrement_entry_counts entry i;

   if A.length entry.all_possible = 0 then begin
      printf p"no possible: %d" i;
      entry.xxx <- true;
      entry.cog <- false;
      entry.best_cog <- false;
      decr cogs
   end
   else begin
      if not !init then begin
         let cog_prob = entry.cog_prob *. cog_prior in
         let len = A.length entry.word_ug.pre + A.length entry.word_ug.stm + A.length entry.word_ug.suf + 1 in
         let noncog_prob = (1. -. cog_prior) *. exp (10. +. foi len *. (log 1. -. log 31.)) in
         entry.best_cog <- (cog_prob > noncog_prob);
      end;

      let probs = A.map (begin fun p -> 
            let pre = p.p_ug.pre in
            let stm = p.p_ug.stm in
            let suf = p.p_ug.suf in
            let pre_ed = p.p_pre_ed in
            let stm_ed = p.p_stm_ed in
            let suf_ed = p.p_suf_ed in
            let pos = p.p_pos in
            morph_prob ~base:true pre pre_ed pos Pre *. 
            morph_prob ~base:true stm stm_ed pos Stm *. 
            morph_prob ~base:true suf suf_ed pos Suf
         end) entry.all_possible in

      let resi, best_prob = max_itemi probs in
      let best = entry.all_possible.(resi) in
      entry.best_prob   <- best_prob;
      entry.best_ug     <- best.p_ug;
      entry.best_hb     <- best.p_hb;
      entry.best_pos    <- best.p_pos;

      L.iter (Ht.incr' d.best_count) best.p_pre_ed;
      L.iter (Ht.incr' d.best_count) best.p_stm_ed;
      L.iter (Ht.incr' d.best_count) best.p_suf_ed;

      if !init then begin
         entry.word_ug  <- best.p_ug;
         entry.word_hb  <- best.p_hb;
         entry.pos      <- best.p_pos;
         entry.pre_ed   <- best.p_pre_ed;
         entry.stm_ed   <- best.p_stm_ed;
         entry.suf_ed   <- best.p_suf_ed;
      end;
      (* printf p"%{float array} %d" probs (count_predictions entry i); *)
      if best_prob = 0. then begin
         entry.xxx <- true;
         entry.cog <- false;
         entry.best_cog <- false;
         decr cogs
      end;

      if entry.cog then begin
         increment_pos_counts entry;
         increment_mrf_counts entry Pre i;
         increment_mrf_counts entry Stm i;
         increment_mrf_counts entry Suf i
      end
   end;
   check_edit_counts i
;;

let sample_morphs () =
   check_edit_counts (-9999);
   A.switeri d.entries (fun i entry ->
      if i mod 100 = 0 then
         printf p"sampling morph  %d" i;
      if not entry.xxx then
         sample_prediction entry i
   );
   (* resample each set of morphs from the base distribution *)
   (* printf p"resampling morphs from base distr...";
    let resample edits indices pos mtype =
       assert (Hs.length indices > 0);

       let mrf = ug_from_edits edits in
       let mrf_counts = get_morph_counts mrf mtype pos in
       let n = foi (Hs.length indices) in
       (* printf p"n = %d,  count = %d" (iof n) (iof $ Ht.count' mrf_counts edits); *)
       assert (n = Ht.count' mrf_counts edits);

       Ht.replace mrf_counts edits 0.;
       let decr_ed ed =
          Ht.decr' d.edit_count ed;
          Ht.add_float d.true_edit_count ed (-.n);
          match ed with
             | Sub _ | End -> d.sub_sum <- d.sub_sum -. 1.; d.true_sub_sum <- d.true_sub_sum -. n
             | Ins _ -> d.ins_sum <- d.ins_sum -. 1.; d.true_ins_sum <- d.true_ins_sum -. n
             | Del _ -> d.del_sum <- d.del_sum -. 1.; d.true_del_sum <- d.true_del_sum -. n
       in
       L.iter decr_ed edits;
       let index = match mtype with Pre -> d.pre_index1 | Stm -> d.stm_index1 | Suf -> d.suf_index1 in
       Ht.remove index (edits,pos);
       
       let poss = get_possible_edits mrf pos mtype in
       let probs = A.map (fun edits -> morph_prob ~base:true mrf edits pos mtype) poss in
       let idx = sample probs in
       let nedits = poss.(idx) in

       Hs.iter (fun i ->
          let entry = d.entries.(i) in
          match mtype with Pre -> entry.pre_ed <- nedits | Stm -> entry.stm_ed <- nedits | Suf -> entry.suf_ed <- nedits
       ) indices;
       Ht.add_float mrf_counts nedits n;
       let incr_ed ed =
          Ht.incr' d.edit_count ed;
          Ht.add_float d.true_edit_count ed n;
          match ed with
             | Sub _ | End -> d.sub_sum <- d.sub_sum +. 1.; d.true_sub_sum <- d.true_sub_sum +. n
             | Ins _ -> d.ins_sum <- d.ins_sum +. 1.; d.true_ins_sum <- d.true_ins_sum +. n
             | Del _ -> d.del_sum <- d.del_sum +. 1.; d.true_del_sum <- d.true_del_sum +. n
       in
       L.iter incr_ed nedits;
       if not (Ht.mem index (nedits,pos)) then
          Ht.add index (nedits,pos) (Hs.create 500 (-1));
       Hs.update (Ht.find index (nedits,pos)) indices      
    in
    let a_pre = Ht.to_array d.pre_index1 in
    let a_stm = Ht.to_array d.stm_index1 in
    let a_suf = Ht.to_array d.suf_index1 in
    A.iter (fun ((eds,pos),indices) -> resample eds indices pos Pre) a_pre;
    A.iter (fun ((eds,pos),indices) -> resample eds indices pos Stm) a_stm;
    A.iter (fun ((eds,pos),indices) -> resample eds indices pos Suf) a_suf; *)
;;

(* let get_ll () =
   let gp = gammas_prior () in
   let gl = gammas_ll () in
   let  *)
   
let write_output () =
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/ugaritic_" ^ soi !r ^ ".out") 
      (fun out -> Array.print ~first:"" ~last:"\n" ~sep:"\n" entry_print out d.entries)
;;
let write_best () =
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/best_ugaritic_" ^ soi !r ^ ".out") 
      (fun out -> Array.print ~first:"" ~last:"\n" ~sep:"\n" entry_print_best out d.entries)
;;
let write_gammas () =
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/gammas_" ^ soi !r ^ ".counts")
      (fun out -> 
         let a = Ht.to_array (Ht.filter id d.gammas) in
         A.sort (fun x y -> compare (edit_to_int (fst x)) (edit_to_int (fst y))) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" (tuple2_print ~first:"" ~last:"" ~sep:"\t\t" edit_print Bool.print) out a); 
;;
let write_edit_counts () = 
   let tup_print out (e,c) =
      fprintf out p"%{edit}\t\t%B\t%8d" e (Ht.find d.gammas e) (iof c)
   in
   let f a out =
      A.sort (fun x y -> compare (edit_to_int (fst x)) (edit_to_int (fst y))) a;
      Array.print ~first:"" ~last:"\n" ~sep:"\n" tup_print out a
   in
   let a1 = Ht.to_array (Ht.filter (fun c -> c > 0.) d.edit_count) in
   let a2 = Ht.to_array (Ht.filter (fun c -> c > 0.) d.true_edit_count) in
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/edits_" ^ soi !r ^ ".counts") (f a1);
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/true_edits_" ^ soi !r ^ ".counts") (f a2);
;;
let write_best_counts () = 
   let tup_print out (e,c) =
      fprintf out p"%{edit}\t\t%B\t%8d" e (Ht.find d.gammas e) (iof c)
   in
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/best_edits_" ^ soi !r ^ ".counts")
      (fun out -> 
         let a = Ht.to_array (Ht.filter (fun c -> c > 0.) d.best_count) in
         A.sort (fun x y -> compare (edit_to_int (fst x)) (edit_to_int (fst y))) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" tup_print out a); 
;;
let write_morph_counts () =
   let f ht out = 
      let res = Ht.create 20 in
      foreach (Ht.enum ht) (fun ((morph,pos), ht2) ->
         foreach (Ht.enum ht2) (fun (el,hs) ->
            let ug_str = d.decode_ug morph in
            let hb_str = d.decode_hb (hb_from_edits el) in
            Ht.add_int res (ug_str,hb_str,pos) (Hs.length hs)));
      let a = Ht.to_array (Ht.filter (fun c -> c > 0) res) in
      A.sort (fun x y -> - compare (snd x) (snd y)) a;
      Array.print ~first:"" ~last:"\n" ~sep:"\n"
         (fun out ((ug_str,hb_str,pos), c) -> fprintf out p"%s %s (%s)\t%15d" ug_str hb_str pos c)
         out a
   in
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/pre_" ^ soi !r ^ ".counts") (f d.pre_tbls);
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/stm_" ^ soi !r ^ ".counts") (f d.stm_tbls);
   File.with_file_out ~mode:[`trunc;`text;`create] ("output/suf_" ^ soi !r ^ ".counts") (f d.suf_tbls);
;;

let set_to_best () =
   A.switeri d.entries (fun i entry ->
      if not entry.xxx then begin
         if entry.cog then decrement_entry_counts entry i;
         
         entry.word_ug <- entry.best_ug;
         entry.word_hb <- entry.best_hb;
         entry.pos <- entry.best_pos;
         entry.cog <- entry.best_cog;

         if entry.cog then begin
            increment_pos_counts entry;
            increment_mrf_counts entry Pre i;
            increment_mrf_counts entry Stm i;
            increment_mrf_counts entry Suf i
         end
      end
   )
;;  
let eval () =
   let pre_er = Ht.create 500 in
   let stm_er = Ht.create 500 in
   let suf_er = Ht.create 500 in
   let pre_erb = Ht.create 500 in
   let stm_erb = Ht.create 500 in
   let suf_erb = Ht.create 500 in

   let cog_tp        = ref 0 in
   let cog_fp        = ref 0 in
   let cog_true      = ref 0 in
    
   let perfectb      = ref 0 in
   let perfect       = ref 0 in
   let dist_totalb   = ref 0 in
   let dist_total    = ref 0 in
   
   let perfect_wb    = ref 0 in
   let perfect_w     = ref 0 in
   let dist_total_wb = ref 0 in
   let dist_total_w  = ref 0 in
   
   Ht.clear d.best_count;
   A.switeri d.entries (fun i entry ->
      if i mod 1 = 100 then 
         printf p"eval: %d" i;

      if not entry.xxx then
         best_prediction entry i;
      (* if !init then 
         (entry_print stdout entry; print_newline ()); *)
      
      if not entry.true_cog then
         (if entry.best_cog then incr cog_fp)
      
      else begin   
         incr cog_true;
         if entry.best_cog then incr cog_tp;
         
         let ug_preb = d.decode_ug entry.best_ug.pre in
         let ug_stmb = d.decode_ug entry.best_ug.stm in
         let ug_sufb = d.decode_ug entry.best_ug.suf in
         let ug_pre = d.decode_ug entry.word_ug.pre in
         let ug_stm = d.decode_ug entry.word_ug.stm in
         let ug_suf = d.decode_ug entry.word_ug.suf in

         let pre_prdb = d.decode_hb entry.best_hb.pre in
         let stm_prdb = d.decode_hb entry.best_hb.stm in
         let suf_prdb = d.decode_hb entry.best_hb.suf in
         (* let suf_prdb = let tmp = d.decode_hb entry.best_hb.suf in 
            if tmp = "m" then "ym" else if tmp = "t" then "h" else tmp
         in *)
         let wrd_prdb = pre_prdb ^ stm_prdb ^ suf_prdb in

         let pre_prd = d.decode_hb entry.word_hb.pre in
         let stm_prd = d.decode_hb entry.word_hb.stm in
         let suf_prd = d.decode_hb entry.word_hb.suf in
         (* let suf_prd = let tmp = d.decode_hb entry.word_hb.suf in 
            if tmp = "m" then "ym" else if tmp = "t" then "h" else tmp
         in *)
         let wrd_prd = pre_prd ^ stm_prd ^ suf_prd in

         let pres = L.map (fun w -> d.decode_hb w.pre) entry.true_words_hb in
         let stms = L.map (fun w -> d.decode_hb w.stm) entry.true_words_hb in
         let sufs = L.map (fun w -> d.decode_hb w.suf) entry.true_words_hb in
         let wrds = L.map (fun w -> d.decode_hb w.pre ^ d.decode_hb w.stm ^ d.decode_hb w.suf) entry.true_words_hb in

         let pre_distsb = L.map (edit_dist pre_prdb) pres in
         let stm_distsb = L.map (edit_dist stm_prdb) stms in
         let suf_distsb = L.map (edit_dist suf_prdb) sufs in
         let wrd_distsb = L.map (edit_dist wrd_prdb) wrds in
         let pre_dists = L.map (edit_dist pre_prd) pres in
         let stm_dists = L.map (edit_dist stm_prd) stms in
         let suf_dists = L.map (edit_dist suf_prd) sufs in
         let wrd_dists = L.map (edit_dist wrd_prd) wrds in

         let preib, pre_distb = L.min_itemi pre_distsb in
         let stmib, stm_distb = L.min_itemi stm_distsb in
         let sufib, suf_distb = L.min_itemi suf_distsb in
         let wrd_distb = L.min wrd_distsb in

         let prei, pre_dist = L.min_itemi pre_dists in
         let stmi, stm_dist = L.min_itemi stm_dists in
         let sufi, suf_dist = L.min_itemi suf_dists in
         let wrd_dist = L.min wrd_dists in

         if pre_distb = 0 then incr perfectb else Ht.incr pre_erb (ug_preb, pre_prdb, L.nth pres preib);
         if pre_dist = 0 then incr perfect else Ht.incr pre_er (ug_pre, pre_prd, L.nth pres prei);
         if stm_distb = 0 then incr perfectb else Ht.incr stm_erb (ug_stmb, stm_prdb, L.nth stms stmib);
         if stm_dist = 0 then incr perfect else Ht.incr stm_er (ug_stm, stm_prd, L.nth stms stmi);
         if suf_distb = 0 then incr perfectb else Ht.incr suf_erb (ug_sufb, suf_prdb, L.nth sufs sufib);
         if suf_dist = 0 then incr perfect else Ht.incr suf_er (ug_suf, suf_prd, L.nth sufs sufi);
         if wrd_distb = 0 then incr perfect_wb;
         if wrd_dist = 0 then incr perfect_w;
         dist_total     := !dist_total + pre_dist + stm_dist + suf_dist;
         dist_total_w   := !dist_total_w + wrd_dist;
         dist_totalb    := !dist_totalb + pre_distb + stm_distb + suf_distb;
         dist_total_wb  := !dist_total_wb + wrd_distb;
      end
   );
   let n_w = A.count (fun e -> e.true_cog) d.entries in
   let n = n_w * 3 in
   printf p"perfect mrfs  = %f (%f)" (foi !perfectb /. foi n) (foi !perfect /. foi n);
   printf p"avg edit dist = %f (%f)" (foi !dist_totalb /. foi n) (foi !dist_total /. foi n);
   printf p"perfect wrds  = %f (%f)" (foi !perfect_wb /. foi n_w) (foi !perfect_w /. foi n_w);
   printf p"avg edit dist = %f (%f)" (foi !dist_total_wb /. foi n_w) (foi !dist_total_w /. foi n_w);
   printf p"cog prediction:  pr = %f, re = %f" (foi !cog_tp /. foi (!cog_tp + !cog_fp)) (foi !cog_tp /. foi !cog_true); 

   let write fn ht =
      File.with_file_out ~mode:[`trunc;`text;`create] fn
      (fun out -> 
         let a = Ht.to_array ht in
         A.sort (fun x y ->  - compare (snd x) (snd y)) a;
         Array.print ~first:"" ~last:"\n" ~sep:"\n" (tuple2_print ~first:"" ~last:"" ~sep:"\t\t" (tuple3_print S.print S.print S.print) Int.print) out a)
   in
   write ("output/best_pre_" ^ soi !r ^".errors") pre_erb;
   write ("output/best_stm_" ^ soi !r ^".errors") stm_erb;
   write ("output/best_suf_" ^ soi !r ^".errors") suf_erb;
   write ("output/pre_" ^ soi !r ^".errors") pre_er;
   write ("output/stm_" ^ soi !r ^".errors") stm_er;
   write ("output/suf_" ^ soi !r ^".errors") suf_er;
;;
let main () =
   (* write_gammas (); *)
   cogs := A.length d.entries;
   
   (* A.iteri all_possible_predictions d.entries;
   eval ();
   init_gammas ();
   write_output ();
   write_edit_counts ();
   write_morph_counts ();
   incr r;
   
   A.iteri all_possible_predictions d.entries;   
   eval ();
   init_gammas2 ();
   write_output ();
   write_edit_counts ();
   write_morph_counts (); *)
   
   (* should be equivalent to the above, but faster for debugging purposes *)
   init_gammas_debug (); 
   A.iteri all_possible_predictions d.entries;
   write_output ();
   eval ();
   write_output ();
   write_edit_counts ();
   write_morph_counts ();

   init := false;
   while !r < rounds do
      incr r;
      brintf  "SAMPLING round = %d (%d cogs)" (!r) !cogs;
      sample_morphs ();
      write_edit_counts ();
      sample_gammas ();
      
      if !r mod 3 = 2 then begin
         printf p"evaluating...";
         eval ();
         write_best ();
         write_best_counts ();
         (* if !r = 2 then begin
            printf  p"setting to best..";
            set_to_best ();
            eval ();
         end; *)
      end;
      write_output ();
      (* write_gammas (); *)
      write_edit_counts ();
      write_morph_counts ();
   done
;;







let _ = Callback.register "edit_prob" edit_prob_c;;
if not !Sys.interactive then main ()
